{"meta":{"title":"khadron的程序人生","subtitle":null,"description":null,"author":"khadron","url":"https://khadron.github.io"},"pages":[{"title":"about","date":"2018-02-02T03:12:59.000Z","updated":"2020-03-18T06:34:18.124Z","comments":true,"path":"about/index.html","permalink":"https://khadron.github.io/about/index.html","excerpt":"","text":"关于 khadron 90后 爱好看电影 khadron@163.com 混迹于行业9年（2020） 该尝试的都尝试了 该见识的也见识了 有一些积累想找一个地方记录下来 于是乎就有了这个博客"}],"posts":[{"title":"Webpack&Babel学习","slug":"Webpack-Babel学习","date":"2020-08-09T15:04:58.000Z","updated":"2020-08-09T15:12:12.618Z","comments":true,"path":"2020/08/09/Webpack-Babel学习/","link":"","permalink":"https://khadron.github.io/2020/08/09/Webpack-Babel学习/","excerpt":"","text":"Webpack &amp; Babel学习 初始化 12mkdir webpack-study &amp;&amp; cd webpack-study //创建并进入项目文件夹 Babel 概念 Babel 是一个 JavaScript 编译器，主要用于把 ECMAScript 2015+ 版本语法的代码转换为 ECMAScript 5 及以下版本的语法，以便运行在当前和旧版本浏览器或其他环境中（node） 一般编译器编译过程分为 4 个阶段输入、解析、转换和输出。Babel 本身不参与解析和转换阶段，这两个阶段需要 Plugins（插件）和 Presets（预设）来实现 Plugins（插件） 用来告诉 babel 如何解析/转换代码。Presets（预设）用来告诉 babel 转换代码时要使用那些新语法特性，它的本质就是一组 Plugin的集合。 Babel 插件分为两类： 转换插件 语法插件 解析（parse）为特定类型的语法 plugins/presets 路径 如果插件用 npm 安装，那可以直接写插件的名称，babel 会自动检查 node_modules 目录里是否安装 123&#123; \"plugins\"：[\"babel-plugin-myPlugin\"]&#125; 也可以指定插件的相对/绝对路径 123&#123; \"plugins\": [\"./myPlugin\"]&#125; 还可以使用短名称 12345678&#123; \"plugins\": [ \"myPlugin\", \"babel-plugin-myPlugin\", // 两个插件实际是同一个 \"@org/babel-plugin-name\", \"@org/name\" // 两个插件实际是同一个 ]&#125; plugins/presets 执行顺序： 插件执行的顺序是按照书写顺序依次执行的 Plugin（插件）在 Presets 前运行 Plugin（插件）顺序从前往后 Preset 顺序是颠倒的（从后往前） 123&#123; \"plugins\": [\"transform-decorators-legacy\", \"transform-class-properties\"]&#125; 如上所示，先执行 transform-decorators-legacy，再执行 transform-class-properties 而 presets的顺序是颠倒的 123&#123; \"presets\": [\"es2015\", \"react\", \"stage-2\"]&#125; 先执行 stage-2、react然后是 es2015 插件参数： 插件参数由插件名和参数对象组成一个数组，可以在配置文件（.babelrc/babel.config.js）中设置 如果不指定参数，下面这几种形式都是一样的： 123&#123; \"plugins\": [\"pluginA\", [\"pluginA\"], [\"pluginA\", &#123;&#125;]]&#125; 如果指定参数，则传递一个对象 123456789101112131415161718&#123; \"plugins\": [ [ \"transform-async-to-module-method\", &#123; \"module\": \"blubird\" &#125; ] ], \"presets\": [ [ \"env\", &#123; \"modules\": false &#125; ] ]&#125; 安装 Babel 12345npm install --save-dev @babel/core @babel/cli @babel/preset-envnpm install --save @babel/polyfill# 可选npm install --save @babel/runtimenpm install --save-dev @babel/plugin-transform-runtime @babel/core babel 的核心，必选 @babel/cli babel 命令行工具，执行 babel 编译 @babel/preset-env 官方用于转换 ECMAScript 2015+语法的插件集合，可根据配置来按需加载插件 （向下支持维度） @babel/polyfill 官方用来创建一个当前和旧版本浏览器能支持 ECMAScript 2015+语法的环境，比如让 IE8 支持Promise。（向上支持维度） @babel/runtime 和 @babel/plugin-transform-runtime 有时候语法的转换相对复杂，可能会需要额外的辅助函数，比如转换 ECMA 2015 的class 12345678910111213/* 源文件 */class Person &#123;&#125;/* 编译后文件 */function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125;&#125;var Person = function Person() &#123; _classCallCheck(this, Person);&#125;; 上面的转换需要一个_classCallCheck 辅助函数，试想假如我们多个文件中使用了class，那么每个文件都需要定义一遍 _classCallCheck 函数，这样不止代码冗余，也会增加文件大小。假如将这些辅助函数抽离到一个包当中，由所有文件共同引用那该多好，而 @babel/runtime 就是做这件事的。 我们已经知道 @babel/runtime 提供了各式各样的辅助函数，但是我们如何知道该引用那个辅助函数呢？ Babel 提供了@babel/plugin-transform-runtime插件帮我们做这件事情 同时@babel/plugin-transform-runtime插件还为我们提供了一个沙箱环境（sandboxed environment），创建一个自己的内部作用域，防止污染全局变量，这在编写一些类库等公共设施代码的时候尤为重要。 需要注意的是： 1、两个包引入的范围不一样：一个在运行时引入，一个在开发时引入 2、plugin-transform-runtime 已经默认包括了 @babel/polyfill，因此不用在独立引入。 Babel 配置 Babel的配置文件有两种格式 .babelrc 和 babel.config.js .babelrc 和 bable.config.js 区别是 babel.config.js 通过编程的方式来创建配置的，.babelrc就是一个配置文件， 相比 bable.config.js来说是静态的 推荐使用 babel.config.js 来配置 Babel @babel/preset-env 指定运行环境，只有 IE8 及以上版本浏览器不支持的让ECMAScript 2015+语法才会被转换 1234567891011&#123; \"presets\": [ \"@babel/preset-env\", &#123; \"targets\": &#123; \"browsers\": \"ie &gt;= 8\" &#125;, \"modules\": false // 将ES 2015模块转换为其他模块规范，可选 \"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | \"cjs\" | \"auto\" | false 默认是 \"auto\" &#125; ]&#125; @babel/polyfill 按需 polyfill 用useBuiltIns配置项来实现。 1234567891011121314&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"modules\": false, \"useBuiltIns\": \"entry\", \"targets\": &#123; \"browsers\": \"ie &gt;= 8\" &#125; &#125; ] ]&#125; useBuiltIns的值可以是entry和usage。 entry：会在入口处把所有 IE8 及以上浏览器不支持 ECMAScript 2015 的特性 polyfill 引入进来。 usage：会扫描要转换的代码，只有代码中用到哪个新特性，它才会引入响应的 polyfill @babel/runtime 和 @babel/plugin-transform-runtime 123456789101112131415161718192021&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"modules\": false, \"targets\": &#123; \"browsers\": \"ie &gt;= 8\" &#125; &#125; ] ], \"plugins\": [ [ \"@babel/plugin-transform-runtime\", &#123; \"corejs\": 2 &#125; ] ]&#125; 注意： 上面corejs的值可以设置为false或2。为什么这样？ 大家都知道 corejs 是给低版本浏览器提供接口的库，如 Promise，map，set 等。在 Babel 中你设置为 false 或者不设置，就是引入 corjs 中的库，而且是全局引入，会污染全局变量。如果不想全局引入，不要让引入的库影响全局，那就需要把 corejs 的值设为 2 还要注意一点，如果 corejs 值设为 2，那就需要再引入一个库 12npm install --save core-js@2npm install --save-dev @babel/runtime-corejs2 执行 Babel 编译命令 1npx babel 源文件路径 --out-dir 编译后文件路径 webpack 概念 webpack 是一个 JavaScript 应用程序的静态模块打包器(module bundler)。 当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 entry（入口） entry 指示 webpack 应该使用哪个模块来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点的依赖（直接和间接）。每个依赖项随机被处理，最后输出到称之为 bundules 的文件中 入口点可以有一个或多个，默认值为 ./src output（出口） output 指示 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist 注意，即使有多个 entry ,但只能有一个 output loader（加载器） loader 使 webpack 拥有处理那些非 JavaScript 文件的能力。loader 可以将所有类型的文件转换为 webpack 能够处理的模块，然后你就可以在 webpack 中处理这些模块 plugins（插件） loader 被用于转换某些类型的模块，而 plugins 则可以用于执行范围更广的任务 mode（模式） 模式有两种，development和 production modules（模块） substitutions（文件名占位符） 安装 webpack 123npm install --save-dev webpacknpm install --save-dev webpack-cli //webpack命令行工具 webpack 配置 webpack 通过 webpack.config.js 文件来进行配置 123// webpack。config.jsmodule.exports = &#123;&#125;; entry 配置 entry 的值可以接受字符串、对象、字符串数组 当值为字符串或对象（只有一个 key）或字符串数组时表示单个入口，如下所示 1234567891011121314// 字符串module.exports = &#123; entry: \"./src/index.js\",&#125;;// 对象module.exports = &#123; entry: &#123; main: \"./scr/index.js\", &#125;,&#125;;// 字符串数组module.exports = &#123; entry: [\"./src/polyfill.js\", \"./src/index.js\"],&#125;; entry 值为数组表示数组中的文件一般是没有相互依赖关系的，但是又处于某些原因需要将它们打包在一起，如上面的 polyfill.js 和 index.js 会打包到一起 多个入口 实现多个入口配置只需要让 entry 属性值为对象就行了，一般会有两个应用场景 分离应用（app）和第三方库 123456module.exports = &#123; entry: &#123; app: \"./src/index.js\", vendors: \"./scr/lib/jquery.js\", &#125;,&#125;; 分离第三方库不推荐上面的方法，可以使用 webpack 的 DllPlugin 插件 多页面应用（app） 1234567module.exports = &#123; entry:&#123; pageOne:'./src/pageOne/index.js', pageTwo:'./src/pageTwo/index.js'. pageThree:'./src/pageThree/index.js' &#125;&#125; output 配置 output 的值是一个对象，里面有 未完待续…… Babel 与 webpack 结合 1npm install babel-loader -D 未完待续……","categories":[],"tags":[]},{"title":"react native之旅-1 环境搭建","slug":"react-native之旅-1-环境搭建","date":"2020-05-23T03:21:21.000Z","updated":"2020-05-31T01:49:57.833Z","comments":true,"path":"2020/05/23/react-native之旅-1-环境搭建/","link":"","permalink":"https://khadron.github.io/2020/05/23/react-native之旅-1-环境搭建/","excerpt":"","text":"react native之旅-1 环境搭建 无论哪种语言或技术，环境搭建是第一步，react native也是如此。由于众所周知的原因，造成react natvie环境搭建“异常艰难”o(╥﹏╥)o 在趟了“无数”坑后，我总结成这篇博客，一来有个记录，二来留给他人参考少走弯路，以下内容都是我摸索出来的经验，无需翻墙100%可用！ react natvie 版本 0.62 安装依赖 node &amp; watchman &amp; yarn node不必多说，前端必备 Watchman是 facebook 的一个开源项目，它开源用来监视文件并且记录文件的改动情况，当文件变更它可以触发一些操作,例如执行一些命令等等。 Yarn是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载 12345brew install nodebrew install watchman npm install -g yarn Xcode Xcode 10 &lt;= version 启动 Xcode，并在Xcode | Preferences | Locations菜单中检查一下是否装有某个版本的Command Line Tools。Xcode 的命令行工具中包含一些必须的工具，比如git等。 Cocoapods CocoaPods 是用 Ruby 编写的包管理器。所以首先看一下你电脑上是否安装了Ruby 1ruby -v 一般MacOS都自带Ruby，但目前Cocapods最新版本似乎不能在 ruby2.6 版本以下安装，意味着如果你使用的 macOS 版本低于 10.15 (Catalina) 则无法直接安装。可以尝试安装较旧一些的版本。如sudo gem install cocoapods -v 1.8.4。 可以使用下面命令来升级Ruby 1gem update --system 切换Ruby镜像源 123gem sources -l # 查看镜像源gem sources --remove https://rubygems.org/ # 移除当前镜像源gem sources -a https://gems.ruby-china.com/ # 添加国内镜像源 安装Cocoapods 12sudo gem install cocoapods # Mac OS X 10.11前sudo gem install -n /usr/local/bin cocoapods # Mac OS X 10.11后 更新Cocoapods/Specs 123cd ~/.cocoapods/repos pod repo remove mastergit clone https://gitee.com/mirrors/CocoaPods-Specs.git ~/.cocoapods/repos/ # 码云镜像源 完全卸载Cocoapods 1sudo gem uninstall -n /usr/local/bin cocoapods cocoapods-core cocoapods-deintegrate cocoapods-downloader cocoapods-plugins cocoapods-search cocoapods-stats cocoapods-trunk cocoapods-try 创建新项目 如果你之前全局安装过旧的react-native-cli命令行工具，请使用npm uninstall -g react-native-cli卸载掉它以避免一些冲突。 现在初始化项目工具不需要安装react-native-cli，直接使用 npx命令（避免全局安装模块） 1npx react-native init AwesomeProject 注意事项： 如果你身处国内并执行上面的命令，那么会卡在 Installing CocoaPods dependencies 这一步，原因是国内访问Cocoapods/Specs特别慢，造成超时。 Cocoapods新版本中即使你配置了国内镜像也没有效果，原因是你还差一步：进入自己的工程，在自己工程的podFile第一行加上： 1source 'https://gitee.com/mirrors/CocoaPods-Specs.git' 然后执行 cd ./项目名/ios &amp;&amp; pod install 就“万事大吉”了 编译并运行 React Native 应用 1234cd AwesomeProjectyarn ios# 或者yarn react-native run-ios 最后 致敬那些提供国内镜像的开发者及组织！！！","categories":[],"tags":[]},{"title":"那些年经历过的面试题","slug":"那些年经历过的面试题","date":"2020-05-06T06:03:16.000Z","updated":"2020-07-20T03:09:05.298Z","comments":true,"path":"2020/05/06/那些年经历过的面试题/","link":"","permalink":"https://khadron.github.io/2020/05/06/那些年经历过的面试题/","excerpt":"","text":"那些年经历过的面试题 初级 Javascript 基本数据类型有哪几种？ boolean null undefined number string symbol (es6 新增类型，表示独一无二的值，由 Symbol 函数生成) 谈谈typeof typeof 对于基本数据类型来说，除了null都可以显示正确类型： 123456typeof undefined; // \"undefined\"typeof null; // \"object\" ???typeof 0; // \"number\"typeof \"hellow world\"; // \"string\"typeof true; // \"boolean\"typeof Symbol(); // \"symbol\" typeof 对于引用类型来说，除了函数都会显示为 Object 123typeof []; // \"object\"typeof &#123;&#125;; // \"object\"typeof Symbol; // \"function\" 如何准确地判断一个变量的数据类型？ 判断数组类型 12345// instanceof 确定对象是否为指定的对象类型的实例，用来识别正在处理的对象的类型[] instanceof Array;// isPrototypeOf 判断一个对象是否存在另一个对象的原型链上Array.prototype.isPrototypeOf([]); “万能”数据类型判断 toString会将this对象的[[class]]属性值拿到，而这个属性值就是该对象的真实类型 123// Object.prototype.toString.call(变量) === \"[数据类型]\"Object.prototype.toString.call(\"\") === \"[object String]\";Object.prototype.toString.call([]) === \"[object Array]\"; null 是对象吗？ 不是，在 JavaScript 最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头表示是对象，然而 null 表示为全零，所以将它错误判断为 Object 函数声明与函数表达式的区别？ 在JavaScript中，解析器会率先读取函数声明，并使其在执行任何代码之前可以访问，至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行 闭包是什么？ （未完待续） 浅拷贝和深拷贝 继承","categories":[],"tags":[]},{"title":"复杂度分析","slug":"复杂度分析","date":"2020-05-04T02:40:54.000Z","updated":"2020-05-05T08:54:48.550Z","comments":true,"path":"2020/05/04/复杂度分析/","link":"","permalink":"https://khadron.github.io/2020/05/04/复杂度分析/","excerpt":"","text":"复杂度分析 是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。 为什么需要复杂度分析 事后统计法： 测试结果非常依赖测试环境 测试结果受数据规模的影响很大 我们需要一个不用具体的测试数据来测试，就可以粗略地估算计算法的执行效率的方法。 时间、空间复杂度分析方法 大 O 复杂度表示法 算法的执行效率，粗略地讲，就是算法代码执行的时间。 从 CPU 的角度来看，，每一行代码都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样。但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time(单位时间)。 所有代码的执行时间 T(n)与每行代码的执行次数成正比。 执行多少次 12T(n) = O(f(n)) 大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度 时间复杂度分析 忽略低阶、常量、系数 只关注循环执行次数最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度 12345678910111213function cal(n) &#123; for (let i = 0, l = 100; i &lt; l; i++) &#123; console.log(i); &#125; for (let i = 0; i &lt; n; i++) &#123; console.log(i); &#125; for (let i = 0; i &lt; n; i++) &#123; for (let j = 0; j &lt; n; j++) &#123;&#125; &#125;&#125; 12T(n) = O(max(fn(n),g(n))) 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 123456789101112function cal(n)&#123; for(let i=0;i&lt;n;i++)&#123; foo(i) &#125;&#125;function foo(n)&#123; for(let i=0,i&lt; n;i++)&#123; console.log(i) &#125;&#125; 常见时间复杂度分析 常量阶$O(1)$ 对数阶$O(logn)$ 线性阶$O(n)$ 线性对数阶$O(n)$ 平方阶$O(n^2)$ 、 立方阶$O(n^3)\\cdots$ k 次方阶$O(n^k)$ 指数阶$O(2^n)$ 阶乘阶$O(n!)$ 对于复杂度量级，可以粗略分为两类，多项式量级和非多项式量级。其中非多项式量级只有两个$O(2^n)$和$O(n!)$ 最好、最坏、平均、均摊情况时间复杂度 最好情况时间复杂度（best case time complexity） 在理想的情况下，执行这段代码的时间复杂度 最坏情况时间复杂度（worst case time complexity） 在最糟糕的情况下，执行这段代码的时间复杂度 平均情况时间复杂度（average case time complexity） 均摊时间复杂度（amortized time complexity） 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。 数学知识 对数 换底公式 数列 等差数列 概率 概率乘法","categories":[],"tags":[]},{"title":"指数与对数","slug":"指数与对数","date":"2020-05-01T06:33:30.000Z","updated":"2020-08-09T15:11:00.632Z","comments":true,"path":"2020/05/01/指数与对数/","link":"","permalink":"https://khadron.github.io/2020/05/01/指数与对数/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://khadron.github.io/categories/数据结构/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://khadron.github.io/tags/数学/"}]},{"title":"优雅的异步编程解决方案:async/await","slug":"优雅的异步编程解决方案-async-await","date":"2020-03-20T02:17:36.000Z","updated":"2020-04-04T12:29:58.684Z","comments":true,"path":"2020/03/20/优雅的异步编程解决方案-async-await/","link":"","permalink":"https://khadron.github.io/2020/03/20/优雅的异步编程解决方案-async-await/","excerpt":"","text":"优雅的异步编程解决方案:async/await 虽然 Promise 一定程度上解决了回调地狱的问题，但过多的链式调用也会造成代码可读性不好，而且流程控制也不方便。于是乎 ES7 提出了终极异步编程解决方案-async/await，可以使用同步的代码逻辑来编写异步的代码 先聊一聊 Generator 提到async/await 就不得不说Generator（生成器），它出现在 async/await 之前的异步编程解决方案，async/await 实际上是对Generator的封装。所以在学习async/await之前了解Generator是有必要的 Generator函数是 ES6 提供的一种异步编程解决方案。从语法上理解，它是一个状态机，封装了多个内部状态。执行执行 Generator 函数会返回一个遍历器对象 语法： 1234567891011function* hwGenerator() &#123; yield \"hello\"; yield \"world\"; return \"ending\";&#125;var hw = hwGenerator();hw.next(); // &#123;value: \"hello\", done: false&#125;hw.next(); // &#123;value: \"world\", done: false&#125;hw.next(); // &#123;value: \"ending\", done: true&#125;hw.next(); // &#123;value: undefined, done: true&#125; 首先，Generator 形式上是一个普通的函数，它有两个特征。 function 关键字与函数名之间有一个*号；另一个是函数内部使用yield表达式，定义不同的状态。调用next方法是把yield 后面的内容返回 yield 表达式与 return 很相似，都是返回后面表达式的值。但也有区别，return 语句一个函数里面只能执行一次 ，但 yield 语句可以执行多次。yield还具有“记忆功能“（每次遇yield，函数就会暂停执行，下一次再从该位置继续向后执行），而 return 没有这个功能。在 Generator 函数中 return 表达式返回是 done 为 true 时的 value yield表达式本身没有返回值，next方法接收一个参数，该参数会被当做上一个 yield表达式返的返回值 next或return返回的是一个对象，里面有两个属性value和done，其中done为true表示 Generator 函数已经执行完成，后面再次调用 next也是这个值 Generator 函数原型方法 Generator.prototype.throw 用于抛出错误，然后在 Generator 函数体内捕获，如果 Generator 函数体内没有捕获则抛出到 Generator 函数体外 Generator.prototype.return 返回给定的值并且终结 Generator 函数 123456789101112131415function* fn(num) &#123; try &#123; const r1 = yield num; const r2 = yield r1 + 1; console.log(r2); &#125; catch (e) &#123; console.log(\"捕获错误\", e); &#125;&#125;var g = fn(1);g.next(2); // &#123;value: 1, done: false&#125;g.next(3); // &#123;value: 4, done: false&#125;g.throw(\"出错了\"); // 直接终止，done: trueg.next(); 这里需要注意一点，r1 的值不会保留上一次的值（也就是 2），而是直接用这次 next 方法传入的参数作为值，所以 g.next(3) 中 yield r1+1的 r1 为 3 而并非 2 那 Generator 函数内部是怎么实现的呢？我们借助babel可以窥探到其中的原理，使用 babel 转换上面的代码得到如下的结果： 12345678910111213141516171819202122232425262728293031323334\"use strict\";require(\"regenerator-runtime/runtime\");var _marked = regeneratorRuntime.mark(hwGenerator);function hwGenerator() &#123; return regeneratorRuntime.wrap(function hwGenerator$(_context) &#123; while (1) &#123; switch ((_context.prev = _context.next)) &#123; case 0: _context.next = 2; return \"hello\"; case 2: _context.next = 4; return \"world\"; case 4: return _context.abrupt(\"return\", \"ending\"); case 5: case \"end\": return _context.stop(); &#125; &#125; &#125;, _marked);&#125;var hw = hwGenerator();hw.next();hw.next();hw.next();hw.next(); regenerator-runtime 是 facebook 的开源项目regenerator里的模块，主要是提供Generator、async/await的 ES5 实现，所以 Babel 转换时就直接使用了regenerator-runtime来实现。 可以看到yield表达式都被转换为switch-case的形式了接下来，我们参考regenerator-runtime来实现一个简单的Generator，帮助我们更容易地理解背后的原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function Generator(fn) &#123; if (!fn) &#123; throw new Error(\" 'fn' is required\"); &#125; if (typeof fn !== \"function\") &#123; throw new Error(\" 'fn' must be a function \"); &#125; var context = &#123; prev: 0, next: 0, done: false, stop: function() &#123; this.done = true; &#125; &#125;; return &#123; next: function() &#123; var result = fn(context); if (result === undefined) return &#123; value: undefined, done: true &#125;; return &#123; value: result, done: false &#125;; &#125; &#125;;&#125;function helloWorld() &#123; return Generator(function(_context) &#123; while (1) &#123; switch ((_context.prev = _context.next)) &#123; case 0: _context.next = 2; return \"hello\"; case 2: _context.next = 4; return \"world\"; case 4: _context.next = 5; return \"ending\"; case 5: case \"end\": return _context.stop(); &#125; &#125; &#125;);&#125;var hw = helloWorld();hw.next(); // &#123;value: \"hello\", done: false&#125;hw.next(); // &#123;value: \"world\", done: false&#125;hw.next(); // &#123;value: \"ending\", done: true&#125;hw.next(); // &#123;value: undefined, done: true&#125; Generator 函数的流程管理 上面示例，我们都是手动调用 next 方法从而得到函数的结果，那能不能让 Generator 函数可以自动执行呢？这就涉及到 Generator 函数的流程管理 实现 Generator 函数的流程管理有两种方式Thunk和Promise Thunk 函数最初用于编译器参数求值策略-”传名调用“，Generator 函数出现后，它可用于 Generator 函数的自动执行。下面是一个简单的Thunk函数实现自动执行的示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var readFile = function(fileName, callback) &#123; setTimeout(function() &#123; console.log(fileName); callback(); &#125;, 1000);&#125;;function thunkify(fn) &#123; return function() &#123; var args = new Array(arguments.length); var ctx = this; for (var i = 0; i &lt; args.length; ++i) &#123; args[i] = arguments[i]; &#125; return function(done) &#123; var called; args.push(function() &#123; if (called) return; called = true; done.apply(null, arguments); &#125;); try &#123; fn.apply(ctx, args); &#125; catch (err) &#123; done(err); &#125; &#125;; &#125;;&#125;var readFileThunkify = thunkify(readFile);var gen = function*() &#123; var r1 = yield readFileThunkify(\"路径1\"); console.log(r1); var r2 = yield readFileThunkify(\"路径2\"); console.log(r2);&#125;;function run(fn) &#123; var gen = fn(); function next(err, data) &#123; var result = gen.next(data); if (result.done) &#123; return; &#125; result.value(next); &#125;&#125; Promise 实现 123456789101112131415161718192021222324252627282930var readFilePromise = function(fileName) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; console.log(fileName); resolve(\"文件流\"); &#125;, 1000); &#125;);&#125;;var gen = function*() &#123; var f1 = yield readFilePromise(\"文件1\"); var f2 = yield readFilePromise(\"文件2\"); console.log(f1; console.log(f2;&#125;;function run(gen) &#123; var g = gen(); function next(data) &#123; var result = g.next(data); if (result.done) &#123; return result.value; &#125; result.value.then(function(data) &#123; next(data); &#125;); &#125; next();&#125;run(gen); 通过上面代码可以看出，自动执行的本质就是递归调用 next函数 async 函数 聊完了Generator，接下步入正题来说下async函数 语法 1234567891011121314async function helloWorld() &#123; const hw = await \"Hello World\"; // 普通变量 console.log(hw); const p = await new Promise((resolved, reject) =&gt; &#123; // todo …… resolved(); &#125;).catch(e =&gt; console.error(e)); console.log(p); return \"Promise\";&#125;const result = helloWorld();console.log(result); async 函数很简单，跟普通函数相比，多了个 async 和 await关键字 async 函数执行的时，一旦遇到 await 就会先返回（把”执行权“交出去），等到异步操作完成，再接着执行函数后面的语句（收回”执行权“） async 函数返回一个 Promise 对象，所以可以是使用 Promise 的 then 方法，比如：helloWorld().then(v=&gt;console.log(v),e=&gt;console.log(e)) async 函数返回的 Promise 对象，只有函数内部的异步操作都完成后，才会发生状态改变，也就是执行 then 方法定义的回调函数参数 await 命令只能用于 async 函数之中，如果用在普通函数就会报错， await 命令后面可以是一个 Promise 对象，也可以是普通的变量，如果是 Promise 则返回该对象的结果。反之则直接返回对应的值。 如果 Promise 对象变为 reject 状态，那么整个 async 函数都会中断执行。有些时候我们想虽然发生错误但也不要中断，这是可以将出错的 await 语句放到try...catch里 123456789async function say() &#123; try &#123; await Promise.reject(\"出错了\"); &#125; catch (e) &#123; console.error(e); &#125;&#125;say().then(v =&gt; console.log(v)); 需要注意如果将 forEach 方法参数改成 async函数的话，执行顺序不是依次执行的而是并发执行的 1234567891011121314function handler(data, i) &#123; // todo const t = i === 1 ? 1000 : 0; setTimeout(() =&gt; &#123; console.log(data); &#125;, t);&#125;async function foo() &#123; const datas = [1, 2, 3]; datas.forEach(async function(data, i) &#123; await handler(data, i); &#125;);&#125; 如果想要得到依次执行的结果，可以使用 for 循环 1234567891011121314function handler(data, i) &#123; // todo const t = i === 1 ? 1000 : 0; setTimeout(() =&gt; &#123; console.log(data); &#125;, t);&#125;async function foo() &#123; const datas = [1, 2, 3]; for (let data of datas) &#123; await handler(data); &#125;&#125; aync 函数的优势 更好的语义，async=异步，await=等候 更广的实用性， await 命令后面可以是 Promise 和原始类型值 返回 Promise，可以通过then方法指定下一步操作 async 函数实现原理 前面说到 async/await 实际上是对 Generator的封装，准备的说它是由 Generator函数 + 自动执行器构成，结合前面讲的知识，我们就可以模拟实现 async/await函数了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function run(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; if (typeof gen === \"function\") gen = gen.call(ctx); if (!gen || typeof gen.next !== \"function\") return resolve(gen); onResolved(); function onResolved(data) &#123; var ret; try &#123; ret = gen.next(data); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; function onRejected(err) &#123; var ret; try &#123; ret = gen.throw(err); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; function toPromise(obj)&#123; if(!obj &amp;&amp; 'function' == typeof obj.then)&#123; return obj &#125;else&#123; return Promise.resolve(obj) &#125; &#125; function next(ret) &#123; if (ret.done) return resolve(ret.value); var value= toPromise.call(ctx,ret.value); if(value)&#123; return value.then(onResolved, onRejected); &#125; &#125; next(); &#125;);&#125;","categories":[{"name":"异步编程","slug":"异步编程","permalink":"https://khadron.github.io/categories/异步编程/"}],"tags":[]},{"title":"剖析Promise原理及实现","slug":"剖析Promise原理及实现","date":"2018-03-14T09:35:28.000Z","updated":"2020-07-22T07:59:05.544Z","comments":true,"path":"2018/03/14/剖析Promise原理及实现/","link":"","permalink":"https://khadron.github.io/2018/03/14/剖析Promise原理及实现/","excerpt":"","text":"剖析 Promise 原理及实现 Promise 的是什么 Promise 字面的意思是“许诺、希望”，放到技术层面来说，它是一种异步编程解决方案。 它与语言无关，你可以根据Promise/A+规范,选用不同语言实现自己的 Promise。 Promise 能解决什么问题？ 解决回调地狱问题，比如下面： 123456789101112131415161718192021222324252627function getAData(callback) &#123; // todo something if (callback) &#123; callbak(); &#125;&#125;function getBData(callback) &#123; // todo something if (callback) &#123; callback(); &#125;&#125;function getCData(callback) &#123; // todo something if (callback) &#123; callback(); &#125;&#125;getAData(function () &#123; getBData(function () &#123; getCData(function () &#123; console.log(\"callback hell\"); &#125;); &#125;);&#125;); 代码更有条理，增加可读性 精确控制回调，防止回调次数过多、回调时机不对等问题 Promise 优点和缺点 优点 代码有条理，更容易人阅读和理解 开发人员更安全的处理回调 缺点 Promise 一旦创建，就会立即执行，无法取消 流程控制不太方便，不能跳过某些then 如果不设置回调函数，Promsie 内部抛出错误，不会反应到外部 一堆 then 代码语义不清楚 Promise 状态 Pending（进行中） Resolved/Fulfilled（已完成） Rejected （已失败） 当 Promise 状态为 pending 时： Promise 状态可以转换为 resolved 或 rejected。 当 Promise 状态为 resolved 或 rejected 时：无法转换为其他状态。必须有一个不可改变的值作为 onResolved 或 onRejected 时间处理函数的参数 ES6 标准的 Promise API Promise.prototype.then(resolveHandler,[rejectHandler]) Promise 状态发生改变后的处理，它接收两个参数，一个是 resolved 状态的处理函数，另一个是 reject 状态的处理函数（可选）。它的返回值是一个新的 Promise 对象 1234567891011const p1 = new Promise((resolved,rejected) = &gt;&#123; resolved('hello') // rejected()&#125;)p1.then(ok=&gt;&#123; console.log('ok')&#125;,failed=&gt;&#123; console.log('failed')&#125;) Promise.prototype.catch(rejectHandler) Promise 状态为 rejected 的处理，它的返回值也是一个新的 Promise 对象 123Promise.reject(\"err\").catch((err) =&gt; &#123; console.log(err);&#125;); Promise.prototype.finally(finallyHandler) 无论 Promise 状态是 resolved 还是 rejected 都会执行。同样，它的返回值也是一个新的 Promise 对象 1234567Promise.reject(\"err\") .catch((err) =&gt; &#123; console.log(err); &#125;) .finally(() =&gt; &#123; console.log(\"finally\"); &#125;); Promise.all(iterable) 执行多个 Promise，并且等待所有 Promise 状态变为 resolved，才会调用 then。如果其中一个 Promise 状态为 reject 就会调用 catch。 iterable 必须是一个可迭代的对象，同样，它的返回值也是一个新的 Promise 对象 123456789101112131415const p1 = Promise.resolve(\"p1\");const p2 = Promise.reject(\"p2\");const p3 = \"hello\";Promise.all([p1, p3]).then((values) =&gt; &#123; console.log(values);&#125;);Promise.all([p1, p2, p3]) .then((values) =&gt; &#123; console.log(values); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); Promise.race(iterable) 和Promise.all方法很像，只不过Promise.race方法只要有一个 Promise 状态变为 resolved 就会调用 then 1234567891011121314const p1 = Promise.resolve(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p1\"); &#125;, 600);&#125;);const p2 = Promise.resolve(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p1\"); &#125;, 800);&#125;);Promise.race([p1, p2]).then((value) =&gt; &#123; console.log(value());&#125;); Promise.resolve 返回一个状态为 resovle 的 promise对象 12const p1 = Promise.resolve(\"ok\");console.log(p1); // Promise &#123;&lt;resolved&gt;: \"ok\"&#125; Promise.reject 返回一个状态为 reject 的 promise对象 12const p1 = Promise.resolve(\"reject\");console.log(p1); // Promise &#123;&lt;reject&gt;: \"failed\"&#125; 自己实现一个 Promise 简单造轮子自己实现一个Promise，从而更好的理解Promise内部原理，从而知其所以然 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236function Promise(executor) &#123; if (typeof executor !== \"function\") &#123; // executor必须是一个函数 throw new TypeError(\"Promise executor\" + executor + \"is not a function\"); &#125; if (!(this instanceof Promise)) &#123; // Promise(fn)方式也能正确执行 return new Promise(executor); &#125; var self = this; self.callbacks = []; self.status = \"pending\"; function resolve(value) &#123; setTimeout(function () &#123; if (self.status !== \"pending\") &#123; return; &#125; self.status = \"resolved\"; self.data = value; for (var i = 0, len = self.callbacks.length; i &lt; len; i++) &#123; self.callbacks[i].onResolved(value); &#125; &#125;); &#125; function reject(reason) &#123; setTimeout(function () &#123; if (self.status !== \"pending\") &#123; return; &#125; self.status = \"rejected\"; self.data = reason; for (var i = 0, len = self.callbacks.length; i &lt; len; i++) &#123; self.callbacks[i].onRejected(reason); &#125; &#125;); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;function handlePromise(promise, x, resolve, reject) &#123; var then, executed = false; if (promise === x) &#123; // 防止循环调用 return reject(new Error(\"Chaining cycle detected for promise!\")); &#125; if (x &amp;&amp; (typeof x === \"object\" || typeof x === \"function\")) &#123; try &#123; then = x.then; if (typeof then === \"function\") &#123; then.call( x, function rs(y) &#123; if (executed) &#123; // resolve方法只能执行一次 return; &#125; executed = true; return handlePromise(promise, y, resolve, reject); &#125;, function rj(r) &#123; if (executed) &#123; // reject方法只能执行一次 return; &#125; executed = true; return reject(r); &#125; ); &#125; else &#123; return resolve(x); &#125; &#125; catch (e) &#123; if (executed) &#123; return; &#125; executed = true; return reject(e); &#125; &#125; else &#123; return resolve(x); &#125;&#125;// Promise.thenPromise.prototype.then = function (onResolved, onRejected) &#123; onResolved = typeof onResolved === \"function\" ? onResolved : function (v) &#123; return v; &#125;; onRejected = typeof onRejected === \"function\" ? onRejected : function (r) &#123; return r; &#125;; var self = this; var newPromise; if (self.status === \"resolved\") &#123; return (newPromise = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; var x = onResolved(self.data); // 回传处理后的值 // 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数 handlePromise(promise, x, resolve, reject); &#125; catch (e) &#123; return onRejected(e); &#125; &#125;); &#125;)); &#125; if (self.status === \"rejected\") &#123; return (newPromise = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; try &#123; var x = onResolved(self.data); // todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数 handlePromise(promise, x, resolve, reject); &#125; catch (e) &#123; return onRejected(e); &#125; &#125;); &#125;)); &#125; if (self.status === \"pending\") &#123; return (newPromise = new Promise(function (resolve, reject) &#123; self.callbacks.push(&#123; onResolved: function (value) &#123; try &#123; var x = onResolved(value); // todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数 handlePromise(promise, x, resolve, reject); &#125; catch (e) &#123; return reject(e); &#125; &#125;, onRejected: function (reason) &#123; try &#123; var x = onRejected(reason); // todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数 handlePromise(promise, x, resolve, reject); &#125; catch (e) &#123; return reject(e); &#125; &#125;, &#125;); &#125;)); &#125;&#125;;Promise.prototype.catch = function (onRejected) &#123; return this.then(null, onRejected);&#125;;Promise.prototype.finally = function (fn) &#123; return this.then( function (v) &#123; setTimeout(fn); return v; &#125;, function (r) &#123; setTimeout(fn); throw r; &#125; );&#125;;Promise.resolve = function (value) &#123; var promise = new Promise(function (resolve, reject) &#123; handlePromise(promise, value, resolve, reject); &#125;); return promise;&#125;;Promise.reject = function (reason) &#123; return new Promise(function (resolve, reject) &#123; reject(reason); &#125;);&#125;;Promise.all = function (promises) &#123; return new Promise(function (resolve, reject) &#123; var counter = 0, len = promises.length; var values = new Array(len); for (var i = 0; i &lt; len; i++) &#123; (function (i) &#123; Promise.resolve(promises[i]).then( function (value) &#123; counter++; values[i] = value; if (counter === len) &#123; return resolve(values); &#125; &#125;, function (reason) &#123; return reject(reason); &#125; ); &#125;)(i); &#125; &#125;);&#125;;Promise.race = function (promises) &#123; return new Promise(function (resolve, reject) &#123; for (var i = 0, len = promises.length; i &lt; len; i++) &#123; Promise.resolve(promises[i]).then( function (value) &#123; return resolve(value); &#125;, function (reason) &#123; return reject(reason); &#125; ); &#125; &#125;);&#125;;","categories":[{"name":"异步编程","slug":"异步编程","permalink":"https://khadron.github.io/categories/异步编程/"}],"tags":[]},{"title":"Hexo 填坑指南","slug":"Hexo-填坑指南","date":"2018-02-02T06:30:07.000Z","updated":"2018-02-02T06:37:12.000Z","comments":true,"path":"2018/02/02/Hexo-填坑指南/","link":"","permalink":"https://khadron.github.io/2018/02/02/Hexo-填坑指南/","excerpt":"","text":"Hexo 填坑指南 hexo安装成功，并且正确运行，但是localhost:4000不能访问? 原因是： 你的电脑端口被占用了。福昕阅读器占用了4000端口，而hexo默认的端口是4000，所以他俩端口冲突了 解决方案 打开package.json文件增加如下代码： 12345//...\"scripts\":&#123; \"start\": \"hexo s -p 4666\"&#125;,//... 然后控制台执行npm run start命令 主题页面中【分类】和【标签】点进去有“Cannot GET /xxx/”提示 解决方案： 安装hexo-generator-json-content插件就好了，它会自动生成【分类】和【标签】的目录及文件 推荐Hexo插件 hexo-generator-json-content hexo-deployer-git 常用命令 命令 简写 含义 hexo new &quot;name&quot; hexo n &quot;name&quot; 新建文章 hexo generate hexo g 生成博客 hexo server hexo s 启动服务预览 hexo deploy hexo d 部署 hexo clean 清除缓存 hexo new page 'name' 新建目录","categories":[],"tags":[]}]}