{"meta":{"title":"khadron的程序人生","subtitle":null,"description":null,"author":"khadron","url":"https://khadron.github.io"},"pages":[{"title":"about","date":"2018-02-02T03:12:59.000Z","updated":"2020-03-18T06:34:18.124Z","comments":true,"path":"about/index.html","permalink":"https://khadron.github.io/about/index.html","excerpt":"","text":"关于 khadron 90后 爱好看电影 khadron@163.com 混迹于行业9年（2020） 该尝试的都尝试了 该见识的也见识了 有一些积累想找一个地方记录下来 于是乎就有了这个博客"}],"posts":[{"title":"优雅的异步编程解决方案:async/await","slug":"优雅的异步编程解决方案-async-await","date":"2020-03-20T02:17:36.000Z","updated":"2020-04-04T12:29:58.684Z","comments":true,"path":"2020/03/20/优雅的异步编程解决方案-async-await/","link":"","permalink":"https://khadron.github.io/2020/03/20/优雅的异步编程解决方案-async-await/","excerpt":"","text":"优雅的异步编程解决方案:async/await 虽然 Promise 一定程度上解决了回调地狱的问题，但过多的链式调用也会造成代码可读性不好，而且流程控制也不方便。于是乎 ES7 提出了终极异步编程解决方案-async/await，可以使用同步的代码逻辑来编写异步的代码 先聊一聊 Generator 提到async/await 就不得不说Generator（生成器），它出现在 async/await 之前的异步编程解决方案，async/await 实际上是对Generator的封装。所以在学习async/await之前了解Generator是有必要的 Generator函数是 ES6 提供的一种异步编程解决方案。从语法上理解，它是一个状态机，封装了多个内部状态。执行执行 Generator 函数会返回一个遍历器对象 语法： 1234567891011function* hwGenerator() &#123; yield \"hello\"; yield \"world\"; return \"ending\";&#125;var hw = hwGenerator();hw.next(); // &#123;value: \"hello\", done: false&#125;hw.next(); // &#123;value: \"world\", done: false&#125;hw.next(); // &#123;value: \"ending\", done: true&#125;hw.next(); // &#123;value: undefined, done: true&#125; 首先，Generator 形式上是一个普通的函数，它有两个特征。 function 关键字与函数名之间有一个*号；另一个是函数内部使用yield表达式，定义不同的状态。调用next方法是把yield 后面的内容返回 yield 表达式与 return 很相似，都是返回后面表达式的值。但也有区别，return 语句一个函数里面只能执行一次 ，但 yield 语句可以执行多次。yield还具有“记忆功能“（每次遇yield，函数就会暂停执行，下一次再从该位置继续向后执行），而 return 没有这个功能。在 Generator 函数中 return 表达式返回是 done 为 true 时的 value yield表达式本身没有返回值，next方法接收一个参数，该参数会被当做上一个 yield表达式返的返回值 next或return返回的是一个对象，里面有两个属性value和done，其中done为true表示 Generator 函数已经执行完成，后面再次调用 next也是这个值 Generator 函数原型方法 Generator.prototype.throw 用于抛出错误，然后在 Generator 函数体内捕获，如果 Generator 函数体内没有捕获则抛出到 Generator 函数体外 Generator.prototype.return 返回给定的值并且终结 Generator 函数 123456789101112131415function* fn(num) &#123; try &#123; const r1 = yield num; const r2 = yield r1 + 1; console.log(r2); &#125; catch (e) &#123; console.log(\"捕获错误\", e); &#125;&#125;var g = fn(1);g.next(2); // &#123;value: 1, done: false&#125;g.next(3); // &#123;value: 4, done: false&#125;g.throw(\"出错了\"); // 直接终止，done: trueg.next(); 这里需要注意一点，r1 的值不会保留上一次的值（也就是 2），而是直接用这次 next 方法传入的参数作为值，所以 g.next(3) 中 yield r1+1的 r1 为 3 而并非 2 那 Generator 函数内部是怎么实现的呢？我们借助babel可以窥探到其中的原理，使用 babel 转换上面的代码得到如下的结果： 12345678910111213141516171819202122232425262728293031323334\"use strict\";require(\"regenerator-runtime/runtime\");var _marked = regeneratorRuntime.mark(hwGenerator);function hwGenerator() &#123; return regeneratorRuntime.wrap(function hwGenerator$(_context) &#123; while (1) &#123; switch ((_context.prev = _context.next)) &#123; case 0: _context.next = 2; return \"hello\"; case 2: _context.next = 4; return \"world\"; case 4: return _context.abrupt(\"return\", \"ending\"); case 5: case \"end\": return _context.stop(); &#125; &#125; &#125;, _marked);&#125;var hw = hwGenerator();hw.next();hw.next();hw.next();hw.next(); regenerator-runtime 是 facebook 的开源项目regenerator里的模块，主要是提供Generator、async/await的 ES5 实现，所以 Babel 转换时就直接使用了regenerator-runtime来实现。 可以看到yield表达式都被转换为switch-case的形式了接下来，我们参考regenerator-runtime来实现一个简单的Generator，帮助我们更容易地理解背后的原理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function Generator(fn) &#123; if (!fn) &#123; throw new Error(\" 'fn' is required\"); &#125; if (typeof fn !== \"function\") &#123; throw new Error(\" 'fn' must be a function \"); &#125; var context = &#123; prev: 0, next: 0, done: false, stop: function() &#123; this.done = true; &#125; &#125;; return &#123; next: function() &#123; var result = fn(context); if (result === undefined) return &#123; value: undefined, done: true &#125;; return &#123; value: result, done: false &#125;; &#125; &#125;;&#125;function helloWorld() &#123; return Generator(function(_context) &#123; while (1) &#123; switch ((_context.prev = _context.next)) &#123; case 0: _context.next = 2; return \"hello\"; case 2: _context.next = 4; return \"world\"; case 4: _context.next = 5; return \"ending\"; case 5: case \"end\": return _context.stop(); &#125; &#125; &#125;);&#125;var hw = helloWorld();hw.next(); // &#123;value: \"hello\", done: false&#125;hw.next(); // &#123;value: \"world\", done: false&#125;hw.next(); // &#123;value: \"ending\", done: true&#125;hw.next(); // &#123;value: undefined, done: true&#125; Generator 函数的流程管理 上面示例，我们都是手动调用 next 方法从而得到函数的结果，那能不能让 Generator 函数可以自动执行呢？这就涉及到 Generator 函数的流程管理 实现 Generator 函数的流程管理有两种方式Thunk和Promise Thunk 函数最初用于编译器参数求值策略-”传名调用“，Generator 函数出现后，它可用于 Generator 函数的自动执行。下面是一个简单的Thunk函数实现自动执行的示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var readFile = function(fileName, callback) &#123; setTimeout(function() &#123; console.log(fileName); callback(); &#125;, 1000);&#125;;function thunkify(fn) &#123; return function() &#123; var args = new Array(arguments.length); var ctx = this; for (var i = 0; i &lt; args.length; ++i) &#123; args[i] = arguments[i]; &#125; return function(done) &#123; var called; args.push(function() &#123; if (called) return; called = true; done.apply(null, arguments); &#125;); try &#123; fn.apply(ctx, args); &#125; catch (err) &#123; done(err); &#125; &#125;; &#125;;&#125;var readFileThunkify = thunkify(readFile);var gen = function*() &#123; var r1 = yield readFileThunkify(\"路径1\"); console.log(r1); var r2 = yield readFileThunkify(\"路径2\"); console.log(r2);&#125;;function run(fn) &#123; var gen = fn(); function next(err, data) &#123; var result = gen.next(data); if (result.done) &#123; return; &#125; result.value(next); &#125;&#125; Promise 实现 123456789101112131415161718192021222324252627282930var readFilePromise = function(fileName) &#123; return new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; console.log(fileName); resolve(\"文件流\"); &#125;, 1000); &#125;);&#125;;var gen = function*() &#123; var f1 = yield readFilePromise(\"文件1\"); var f2 = yield readFilePromise(\"文件2\"); console.log(f1; console.log(f2;&#125;;function run(gen) &#123; var g = gen(); function next(data) &#123; var result = g.next(data); if (result.done) &#123; return result.value; &#125; result.value.then(function(data) &#123; next(data); &#125;); &#125; next();&#125;run(gen); 通过上面代码可以看出，自动执行的本质就是递归调用 next函数 async 函数 聊完了Generator，接下步入正题来说下async函数 语法 1234567891011121314async function helloWorld() &#123; const hw = await \"Hello World\"; // 普通变量 console.log(hw); const p = await new Promise((resolved, reject) =&gt; &#123; // todo …… resolved(); &#125;).catch(e =&gt; console.error(e)); console.log(p); return \"Promise\";&#125;const result = helloWorld();console.log(result); async 函数很简单，跟普通函数相比，多了个 async 和 await关键字 async 函数执行的时，一旦遇到 await 就会先返回（把”执行权“交出去），等到异步操作完成，再接着执行函数后面的语句（收回”执行权“） async 函数返回一个 Promise 对象，所以可以是使用 Promise 的 then 方法，比如：helloWorld().then(v=&gt;console.log(v),e=&gt;console.log(e)) async 函数返回的 Promise 对象，只有函数内部的异步操作都完成后，才会发生状态改变，也就是执行 then 方法定义的回调函数参数 await 命令只能用于 async 函数之中，如果用在普通函数就会报错， await 命令后面可以是一个 Promise 对象，也可以是普通的变量，如果是 Promise 则返回该对象的结果。反之则直接返回对应的值。 如果 Promise 对象变为 reject 状态，那么整个 async 函数都会中断执行。有些时候我们想虽然发生错误但也不要中断，这是可以将出错的 await 语句放到try...catch里 123456789async function say() &#123; try &#123; await Promise.reject(\"出错了\"); &#125; catch (e) &#123; console.error(e); &#125;&#125;say().then(v =&gt; console.log(v)); 需要注意如果将 forEach 方法参数改成 async函数的话，执行顺序不是依次执行的而是并发执行的 1234567891011121314function handler(data, i) &#123; // todo const t = i === 1 ? 1000 : 0; setTimeout(() =&gt; &#123; console.log(data); &#125;, t);&#125;async function foo() &#123; const datas = [1, 2, 3]; datas.forEach(async function(data, i) &#123; await handler(data, i); &#125;);&#125; 如果想要得到依次执行的结果，可以使用 for 循环 1234567891011121314function handler(data, i) &#123; // todo const t = i === 1 ? 1000 : 0; setTimeout(() =&gt; &#123; console.log(data); &#125;, t);&#125;async function foo() &#123; const datas = [1, 2, 3]; for (let data of datas) &#123; await handler(data); &#125;&#125; aync 函数的优势 更好的语义，async=异步，await=等候 更广的实用性， await 命令后面可以是 Promise 和原始类型值 返回 Promise，可以通过then方法指定下一步操作 async 函数实现原理 前面说到 async/await 实际上是对 Generator的封装，准备的说它是由 Generator函数 + 自动执行器构成，结合前面讲的知识，我们就可以模拟实现 async/await函数了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function run(gen) &#123; var ctx = this; return new Promise(function(resolve, reject) &#123; if (typeof gen === \"function\") gen = gen.call(ctx); if (!gen || typeof gen.next !== \"function\") return resolve(gen); onResolved(); function onResolved(data) &#123; var ret; try &#123; ret = gen.next(data); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; function onRejected(err) &#123; var ret; try &#123; ret = gen.throw(err); &#125; catch (e) &#123; return reject(e); &#125; next(ret); &#125; function toPromise(obj)&#123; if(!obj &amp;&amp; 'function' == typeof obj.then)&#123; return obj &#125;else&#123; return Promise.resolve(obj) &#125; &#125; function next(ret) &#123; if (ret.done) return resolve(ret.value); var value= toPromise.call(ctx,ret.value); if(value)&#123; return value.then(onResolved, onRejected); &#125; &#125; next(); &#125;);&#125;","categories":[{"name":"异步编程","slug":"异步编程","permalink":"https://khadron.github.io/categories/异步编程/"}],"tags":[]},{"title":"剖析Promise原理及实现","slug":"剖析Promise原理及实现","date":"2018-03-14T09:35:28.000Z","updated":"2020-04-02T07:15:23.397Z","comments":true,"path":"2018/03/14/剖析Promise原理及实现/","link":"","permalink":"https://khadron.github.io/2018/03/14/剖析Promise原理及实现/","excerpt":"","text":"剖析Promise原理及实现 Promise 的是什么 Promise 字面的意思是“许诺、希望”，放到技术层面来说，它是一种异步编程解决方案。 它与语言无关，你可以根据Promise/A+规范,选用不同语言实现自己的 Promise。 Promise 能解决什么问题？ 解决回调地狱问题，比如下面： 123456789101112131415161718192021222324252627function getAData(callback) &#123; // todo something if (callback) &#123; callbak(); &#125;&#125;function getBData(callback) &#123; // todo something if (callback) &#123; callback(); &#125;&#125;function getCData(callback) &#123; // todo something if (callback) &#123; callback(); &#125;&#125;getAData(function() &#123; getBData(function() &#123; getCData(function() &#123; console.log(\"callback hell\"); &#125;); &#125;);&#125;); 代码更有条理，增加可读性 精确控制回调，防止回调次数过多、回调时机不对等问题 Promise 优点和缺点 优点 代码有条理，更容易人阅读和理解 开发人员更安全的处理回调 缺点 Promise一旦创建，就会立即执行，无法取消 流程控制不太方便，不能跳过某些then 如果不设置回调函数，Promsie内部抛出错误，不会反应到外部 一堆 then 代码语义不清楚 Promise 状态 Pending（进行中） Resolved/Fulfilled（已完成） Rejected （已失败） 当 Promise 状态为 pending 时： Promise 状态可以转换为 resolved 或 rejected。 当 Promise 状态为 resolved 或 rejected 时：无法转换为其他状态。必须有一个不可改变的值作为 onResolved 或 onRejected 时间处理函数的参数 ES6 标准的 Promise API Promise.prototype.then(resolveHandler,[rejectHandler]) Promise 状态发生改变后的处理，它接收两个参数，一个是 resolved 状态的处理函数，另一个是 reject 状态的处理函数（可选）。它的返回值是一个新的 Promise 对象 1234567891011const p1 = new Promise((resolved,rejected) = &gt;&#123; resolved('hello') // rejected()&#125;)p1.then(ok=&gt;&#123; console.log('ok')&#125;,faild=&gt;&#123; console.log('faild')&#125;) Promise.prototype.catch(rejectHandler) Promise 状态为 rejected 的处理，它的返回值也是一个新的 Promise 对象 123Promise.reject(\"err\").catch(err =&gt; &#123; console.log(err);&#125;); Promise.prototype.finally(finallyHandler) 无论 Promise 状态是 resolved 还是 rejected 都会执行。同样，它的返回值也是一个新的 Promise 对象 1234567Promise.reject(\"err\") .catch(err =&gt; &#123; console.log(err); &#125;) .finally(() =&gt; &#123; console.log(\"finally\"); &#125;); Promise.all(iterable) 执行多个 Promise，并且等待所有 Promise 状态变为 resolved，才会调用 then。如果其中一个 Promise 状态为 reject 就会调用 catch。 iterable 必须是一个可迭代的对象，同样，它的返回值也是一个新的 Promise 对象 123456789101112131415const p1 = Promise.resolve(\"p1\");const p2 = Promise.reject(\"p2\");const p3 = \"hello\";Promise.all([p1, p3]).then(values =&gt; &#123; console.log(values);&#125;);Promise.all([p1, p2, p3]) .then(values =&gt; &#123; console.log(values); &#125;) .catch(err =&gt; &#123; console.log(err); &#125;); Promise.race(iterable) 和Promise.all方法很像，只不过Promise.race方法只要有一个 Promise 状态变为 resolved 就会调用 then Promise.resolve Promise.reject 1234567891011121314const p1 = Promise.resolve(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p1\"); &#125;, 600);&#125;);const p2 = Promise.resolve(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(\"p1\"); &#125;, 800);&#125;);Promise.race([p1, p2]).then(value =&gt; &#123; console.log(value());&#125;); 自己实现一个 Promise 简单造轮子自己实现一个Promise，从而更好的理解Promise内部原理，从而知其所以然 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236function Promise(executor) &#123; if (typeof executor !== \"function\") &#123; // executor必须是一个函数 throw new TypeError(\"Promise executor\" + executor + \"is not a function\"); &#125; if (!(this instanceof Promise)) &#123; // Promise(fn)方式也能正确执行 return new Promise(executor); &#125; var self = this; self.callbacks = []; self.status = \"pending\"; function resolve(value) &#123; setTimeout(function() &#123; if (self.status !== \"pending\") &#123; return; &#125; self.status = \"resolved\"; self.data = value; for (var i = 0, len = self.callbacks.length; i &lt; len; i++) &#123; self.callbacks[i].onResolved(value); &#125; &#125;); &#125; function reject(reason) &#123; setTimeout(function() &#123; if (self.status !== \"pending\") &#123; return; &#125; self.status = \"rejected\"; self.data = reason; for (var i = 0, len = self.callbacks.length; i &lt; len; i++) &#123; self.callbacks[i].onRejected(reason); &#125; &#125;); &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;function handlePromise(promise, x, resolve, reject) &#123; var then, executed = false; if (promise === x) &#123; // 防止循环调用 return reject(new Error(\"Chaining cycle detected for promise!\")); &#125; if (x &amp;&amp; (typeof x === \"object\" || typeof x === \"function\")) &#123; try &#123; then = x.then; if (typeof then === \"function\") &#123; then.call( x, function rs(y) &#123; if (executed) &#123; // resolve方法只能执行一次 return; &#125; executed = true; return handlePromise(promise, y, resolve, reject); &#125;, function rj(r) &#123; if (executed) &#123; // reject方法只能执行一次 return; &#125; executed = true; return reject(r); &#125; ); &#125; else &#123; return resolve(x); &#125; &#125; catch (e) &#123; if (executed) &#123; return; &#125; executed = true; return reject(e); &#125; &#125; else &#123; return resolve(x); &#125;&#125;// Promise.thenPromise.prototype.then = function(onResolved, onRejected) &#123; onResolved = typeof onResolved === \"function\" ? onResolved : function(v) &#123; return v; &#125;; onRejected = typeof onRejected === \"function\" ? onRejected : function(r) &#123; return r; &#125;; var self = this; var newPromise; if (self.status === \"resolved\") &#123; return (newPromise = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; try &#123; var x = onResolved(self.data); // todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数 handlePromise(promise, x, resolve, reject); &#125; catch (e) &#123; return reject(e); &#125; &#125;); &#125;)); &#125; if (self.status === \"rejected\") &#123; return (newPromise = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; try &#123; var x = onResolved(self.data); // todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数 handlePromise(promise, x, resolve, reject); &#125; catch (e) &#123; return reject(e); &#125; &#125;); &#125;)); &#125; if (self.status === \"pending\") &#123; return (newPromise = new Promise(function(resolve, reject) &#123; self.callbacks.push(&#123; onResolved: function(value) &#123; try &#123; var x = onResolved(value); // todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数 handlePromise(promise, x, resolve, reject); &#125; catch (e) &#123; return reject(e); &#125; &#125;, onRejected: function(reason) &#123; try &#123; var x = onRejected(reason); // todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数 handlePromise(promise, x, resolve, reject); &#125; catch (e) &#123; return reject(e); &#125; &#125; &#125;); &#125;)); &#125;&#125;;Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected);&#125;;Promise.prototype.finally = function(fn) &#123; return this.then( function(v) &#123; setTimeout(fn); return v; &#125;, function(r) &#123; setTimeout(fn); throw r; &#125; );&#125;;Promise.resolve = function(value) &#123; var promise = new MyPromise(function(resolve, reject) &#123; handlePromise(promise, value, resolve, reject); &#125;); return promise;&#125;;Promise.reject = function(reason) &#123; return new MyPromise(function(resolve, reject) &#123; reject(reason); &#125;);&#125;;Promise.all = function(promises) &#123; return new MyPromise(function(resolve, reject) &#123; var counter = 0, len = promises.length; var values = new Array(len); for (var i = 0; i &lt; len; i++) &#123; (function(i) &#123; MyPromise.resolve(promises[i]).then( function(value) &#123; counter++; values[i] = value; if (counter === len) &#123; return resolve(values); &#125; &#125;, function(reason) &#123; return reject(reason); &#125; ); &#125;)(i); &#125; &#125;);&#125;;Promise.race = function(promises) &#123; return new MyPromise(function(resolve, reject) &#123; for (var i = 0, len = promises.length; i &lt; len; i++) &#123; MyPromise.resolve(promises[i]).then( function(value) &#123; return resolve(value); &#125;, function(reason) &#123; return reject(reason); &#125; ); &#125; &#125;);&#125;;","categories":[{"name":"异步编程","slug":"异步编程","permalink":"https://khadron.github.io/categories/异步编程/"}],"tags":[]},{"title":"Hexo 填坑指南","slug":"Hexo-填坑指南","date":"2018-02-02T06:30:07.000Z","updated":"2018-02-02T06:37:12.000Z","comments":true,"path":"2018/02/02/Hexo-填坑指南/","link":"","permalink":"https://khadron.github.io/2018/02/02/Hexo-填坑指南/","excerpt":"","text":"Hexo 填坑指南 hexo安装成功，并且正确运行，但是localhost:4000不能访问? 原因是： 你的电脑端口被占用了。福昕阅读器占用了4000端口，而hexo默认的端口是4000，所以他俩端口冲突了 解决方案 打开package.json文件增加如下代码： 12345//...\"scripts\":&#123; \"start\": \"hexo s -p 4666\"&#125;,//... 然后控制台执行npm run start命令 主题页面中【分类】和【标签】点进去有“Cannot GET /xxx/”提示 解决方案： 安装hexo-generator-json-content插件就好了，它会自动生成【分类】和【标签】的目录及文件 推荐Hexo插件 hexo-generator-json-content hexo-deployer-git 常用命令 命令 简写 含义 hexo new &quot;name&quot; hexo n &quot;name&quot; 新建文章 hexo generate hexo g 生成博客 hexo server hexo s 启动服务预览 hexo deploy hexo d 部署 hexo clean 清除缓存 hexo new page 'name' 新建目录","categories":[],"tags":[]}]}