<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>khadron的程序人生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://khadron.github.io/"/>
  <updated>2020-08-09T15:12:12.618Z</updated>
  <id>https://khadron.github.io/</id>
  
  <author>
    <name>khadron</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webpack&amp;Babel学习</title>
    <link href="https://khadron.github.io/2020/08/09/Webpack-Babel%E5%AD%A6%E4%B9%A0/"/>
    <id>https://khadron.github.io/2020/08/09/Webpack-Babel学习/</id>
    <published>2020-08-09T15:04:58.000Z</published>
    <updated>2020-08-09T15:12:12.618Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="webpack-amp-babel学习">Webpack &amp; Babel学习</span></h1><h3><span id="初始化">初始化</span></h3><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkdir webpack-study &amp;&amp; cd webpack-study    <span class="comment">//创建并进入项目文件夹</span></span><br></pre></td></tr></table></figure></p><h3><span id="babel">Babel</span></h3><h4><span id="概念">概念</span></h4><p><code>Babel</code> 是一个 JavaScript 编译器，主要用于把 ECMAScript 2015+ 版本语法的代码转换为 ECMAScript 5 及以下版本的语法，以便运行在当前和旧版本浏览器或其他环境中（node）</p><p>一般编译器编译过程分为 4 个阶段输入、解析、转换和输出。<code>Babel</code> 本身不参与解析和转换阶段，这两个阶段需要 <code>Plugins（插件）</code>和 <code>Presets（预设）</code>来实现</p><p><code>Plugins（插件）</code> 用来告诉 <code>babel</code> 如何解析/转换代码。<code>Presets（预设）</code>用来告诉 <code>babel</code> 转换代码时要使用那些新语法特性，它的本质就是一组 <code>Plugin</code>的集合。</p><p><code>Babel</code> 插件分为两类：</p><ul><li>转换插件</li><li>语法插件解析（parse）为特定类型的语法</li></ul><p>plugins/presets 路径如果插件用 npm 安装，那可以直接写插件的名称，babel 会自动检查 node_modules 目录里是否安装</p><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "plugins"：["babel-plugin-myPlugin"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以指定插件的相对/绝对路径</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"./myPlugin"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以使用短名称</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"myPlugin"</span>,</span><br><span class="line">    <span class="string">"babel-plugin-myPlugin"</span>, // 两个插件实际是同一个</span><br><span class="line">    <span class="string">"@org/babel-plugin-name"</span>,</span><br><span class="line">    <span class="string">"@org/name"</span> // 两个插件实际是同一个</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>plugins/presets 执行顺序：插件执行的顺序是按照书写顺序依次执行的</p><ul><li><code>Plugin</code>（插件）在 <code>Presets</code> 前运行</li><li><code>Plugin</code>（插件）顺序从前往后</li><li><code>Preset</code> 顺序是颠倒的（从后往前）</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-decorators-legacy"</span>, <span class="string">"transform-class-properties"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，先执行 <code>transform-decorators-legacy</code>，再执行 <code>transform-class-properties</code>而 <code>presets</code>的顺序是颠倒的</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"es2015"</span>, <span class="string">"react"</span>, <span class="string">"stage-2"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先执行 <code>stage-2</code>、<code>react</code>然后是 <code>es2015</code></p><p>插件参数：插件参数由插件名和参数对象组成一个数组，可以在配置文件（.babelrc/babel.config.js）中设置</p><p>如果不指定参数，下面这几种形式都是一样的：</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"pluginA"</span>, [<span class="string">"pluginA"</span>], [<span class="string">"pluginA"</span>, &#123;&#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果指定参数，则传递一个对象</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"transform-async-to-module-method"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"blubird"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"modules"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="安装-babel">安装 Babel</span></h4><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli @babel/preset-env</span><br><span class="line">npm install --save @babel/polyfill</span><br><span class="line"><span class="meta">#</span> 可选</span><br><span class="line">npm install --save @babel/runtime</span><br><span class="line">npm install --save-dev @babel/plugin-transform-runtime</span><br></pre></td></tr></table></figure></p><ul><li>@babel/corebabel 的核心，必选</li><li>@babel/clibabel 命令行工具，执行 babel 编译</li><li>@babel/preset-env官方用于转换 ECMAScript 2015+语法的插件集合，可根据配置来按需加载插件 （向下支持维度）</li><li>@babel/polyfill官方用来创建一个当前和旧版本浏览器能支持 ECMAScript 2015+语法的环境，比如让 IE8 支持<code>Promise</code>。（向上支持维度）</li><li>@babel/runtime 和 @babel/plugin-transform-runtime有时候语法的转换相对复杂，可能会需要额外的辅助函数，比如转换 ECMA 2015 的<strong>class</strong></li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 源文件 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 编译后文件 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  _classCallCheck(<span class="keyword">this</span>, Person);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的转换需要一个_classCallCheck 辅助函数，试想假如我们多个文件中使用了<strong>class</strong>，那么每个文件都需要定义一遍_classCallCheck 函数，这样不止代码冗余，也会增加文件大小。假如将这些辅助函数抽离到一个包当中，由所有文件共同引用那该多好，而 <code>@babel/runtime</code> 就是做这件事的。我们已经知道 <code>@babel/runtime</code> 提供了各式各样的辅助函数，但是我们如何知道该引用那个辅助函数呢？ Babel 提供了<code>@babel/plugin-transform-runtime</code>插件帮我们做这件事情同时<code>@babel/plugin-transform-runtime</code>插件还为我们提供了一个沙箱环境（sandboxed environment），创建一个自己的内部作用域，防止污染全局变量，这在编写一些类库等公共设施代码的时候尤为重要。<strong>需要注意的是：</strong>1、两个包引入的范围不一样：一个在运行时引入，一个在开发时引入2、plugin-transform-runtime 已经默认包括了 @babel/polyfill，因此不用在独立引入。</p><h4><span id="babel-配置">Babel 配置</span></h4><p><code>Babel</code>的配置文件有两种格式 <code>.babelrc</code> 和 <code>babel.config.js</code><code>.babelrc</code> 和 <code>bable.config.js</code> 区别是 <code>babel.config.js</code> 通过编程的方式来创建配置的，<code>.babelrc</code>就是一个配置文件， 相比 <code>bable.config.js</code>来说是静态的推荐使用 <code>babel.config.js</code> 来配置 Babel</p><ul><li>@babel/preset-env指定运行环境，只有 IE8 及以上版本浏览器不支持的让<code>ECMAScript 2015+</code>语法才会被转换</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"targets"</span>: &#123;</span><br><span class="line">        <span class="attr">"browsers"</span>: <span class="string">"ie &gt;= 8"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"modules"</span>: <span class="literal">false</span> // 将ES <span class="number">2015</span>模块转换为其他模块规范，可选 <span class="string">"amd"</span> | <span class="string">"umd"</span> | <span class="string">"systemjs"</span> | <span class="string">"commonjs"</span> | <span class="string">"cjs"</span> | <span class="string">"auto"</span> | <span class="literal">false</span> 默认是 <span class="string">"auto"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>@babel/polyfill按需 polyfill 用<code>useBuiltIns</code>配置项来实现。</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"modules"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"entry"</span>,</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"browsers"</span>: <span class="string">"ie &gt;= 8"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>useBuiltIns</code>的值可以是<code>entry</code>和<code>usage</code>。<code>entry</code>：会在入口处把所有 IE8 及以上浏览器不支持 ECMAScript 2015 的特性 polyfill 引入进来。<code>usage</code>：会扫描要转换的代码，只有代码中用到哪个新特性，它才会引入响应的 polyfill</p><ul><li>@babel/runtime 和 @babel/plugin-transform-runtime</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"modules"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"browsers"</span>: <span class="string">"ie &gt;= 8"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>上面<code>corejs</code>的值可以设置为<code>false</code>或<code>2</code>。为什么这样？大家都知道 corejs 是给低版本浏览器提供接口的库，如 Promise，map，set 等。在 Babel 中你设置为 false 或者不设置，就是引入 corjs 中的库，而且是全局引入，会污染全局变量。如果不想全局引入，不要让引入的库影响全局，那就需要把 corejs 的值设为 2还要注意一点，如果 corejs 值设为 2，那就需要再引入一个库</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save core-js@2</span><br><span class="line">npm install --save-dev @babel/runtime-corejs2</span><br></pre></td></tr></table></figure></p><h4><span id="执行-babel-编译命令">执行 Babel 编译命令</span></h4><p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx babel 源文件路径 --out-dir 编译后文件路径</span><br></pre></td></tr></table></figure></p><h3><span id="webpack">webpack</span></h3><h4><span id="概念">概念</span></h4><p>webpack 是一个 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p><h5><span id="entry入口">entry（入口）</span></h5><p>entry 指示 webpack 应该使用哪个模块来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点的依赖（直接和间接）。每个依赖项随机被处理，最后输出到称之为 bundules 的文件中入口点可以有一个或多个，默认值为 <code>./src</code></p><h5><span id="output出口">output（出口）</span></h5><p>output 指示 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 <code>./dist</code>注意，即使有多个 entry ,但只能有一个 output</p><h5><span id="loader加载器">loader（加载器）</span></h5><p>loader 使 webpack 拥有处理那些非 JavaScript 文件的能力。loader 可以将所有类型的文件转换为 webpack 能够处理的模块，然后你就可以在 webpack 中处理这些模块</p><h5><span id="plugins插件">plugins（插件）</span></h5><p>loader 被用于转换某些类型的模块，而 plugins 则可以用于执行范围更广的任务</p><h5><span id="mode模式">mode（模式）</span></h5><p>模式有两种，<code>development</code>和 <code>production</code></p><h5><span id="modules模块">modules（模块）</span></h5><h5><span id="substitutions文件名占位符">substitutions（文件名占位符）</span></h5><h4><span id="安装-webpack">安装 webpack</span></h4><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">npm install --save-dev webpack</span><br><span class="line">npm install --save-dev webpack-cli    <span class="comment">//webpack命令行工具</span></span><br></pre></td></tr></table></figure></p><h4><span id="webpack-配置">webpack 配置</span></h4><p>webpack 通过 <code>webpack.config.js</code> 文件来进行配置</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack。config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure></p><h5><span id="entry-配置">entry 配置</span></h5><p>entry 的值可以接受字符串、对象、字符串数组当值为字符串或对象（只有一个 key）或字符串数组时表示单个入口，如下所示</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">"./scr/index.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 字符串数组</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [<span class="string">"./src/polyfill.js"</span>, <span class="string">"./src/index.js"</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>entry 值为数组表示数组中的文件一般是没有相互依赖关系的，但是又处于某些原因需要将它们打包在一起，如上面的 <code>polyfill.js</code> 和 <code>index.js</code> 会打包到一起</p><p>多个入口</p><p>实现多个入口配置只需要让 <code>entry</code> 属性值为对象就行了，一般会有两个应用场景</p><ol><li>分离应用（app）和第三方库</li></ol><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">"./src/index.js"</span>,</span><br><span class="line">    vendors: <span class="string">"./scr/lib/jquery.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>分离第三方库不推荐上面的方法，可以使用 webpack 的 DllPlugin 插件</p><ol start="2"><li>多页面应用（app）</li></ol><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        pageOne:<span class="string">'./src/pageOne/index.js'</span>,</span><br><span class="line">        pageTwo:<span class="string">'./src/pageTwo/index.js'</span>.</span><br><span class="line">        pageThree:<span class="string">'./src/pageThree/index.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5><span id="output-配置">output 配置</span></h5><p>output 的值是一个对象，里面有</p><p><strong><em>未完待续……</em></strong></p><h4><span id="babel-与-webpack-结合">Babel 与 webpack 结合</span></h4><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader  -D</span><br></pre></td></tr></table></figure></p><p><strong><em>未完待续……</em></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;webpack-amp-babel学习&quot;&gt;Webpack &amp;amp; Babel学习&lt;/span&gt;&lt;/h1&gt;
&lt;h3&gt;&lt;span id=&quot;初始化&quot;&gt;初始化&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;tab
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>react native之旅-1 环境搭建</title>
    <link href="https://khadron.github.io/2020/05/23/react-native%E4%B9%8B%E6%97%85-1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://khadron.github.io/2020/05/23/react-native之旅-1-环境搭建/</id>
    <published>2020-05-23T03:21:21.000Z</published>
    <updated>2020-05-31T01:49:57.833Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="react-native之旅-1-环境搭建">react native之旅-1 环境搭建</span></h1><p>  无论哪种语言或技术，环境搭建是第一步，<code>react native</code>也是如此。由于众所周知的原因，造成<code>react natvie</code>环境搭建“异常艰难”o(╥﹏╥)o</p><p>  在趟了“无数”坑后，我总结成这篇博客，一来有个记录，二来留给他人参考少走弯路，以下内容都是我摸索出来的经验，无需翻墙100%可用！</p><h4><span id="react-natvie-版本">react natvie 版本</span></h4><p>0.62</p><h4><span id="安装依赖">安装依赖</span></h4><h4><span id="node-amp-watchman-amp-yarn">node &amp; watchman &amp; yarn</span></h4><ul><li><p>node不必多说，前端必备</p></li><li><p>Watchman是 facebook 的一个开源项目，它开源用来监视文件并且记录文件的改动情况，当文件变更它可以触发一些操作,例如执行一些命令等等。</p></li><li><p>Yarn是 Facebook 提供的替代 npm 的工具，可以加速 node 模块的下载</p></li></ul><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install node</span><br><span class="line"></span><br><span class="line">brew install watchman </span><br><span class="line"></span><br><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure></p><h4><span id="xcode">Xcode</span></h4><p>Xcode 10 &lt;= version</p><p>启动 Xcode，并在Xcode | Preferences | Locations菜单中检查一下是否装有某个版本的Command Line Tools。Xcode 的命令行工具中包含一些必须的工具，比如git等。</p><h4><span id="cocoapods">Cocoapods</span></h4><p><code>CocoaPods</code> 是用 Ruby 编写的包管理器。所以首先看一下你电脑上是否安装了Ruby</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure></p><p>一般MacOS都自带Ruby，但目前Cocapods最新版本似乎不能在 ruby2.6 版本以下安装，意味着如果你使用的 macOS 版本低于 10.15 (Catalina) 则无法直接安装。可以尝试安装较旧一些的版本。如sudo gem install cocoapods -v 1.8.4。</p><p>可以使用下面命令来升级Ruby</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem update --system</span><br></pre></td></tr></table></figure></p><p>切换Ruby镜像源</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem sources -l # 查看镜像源</span><br><span class="line">gem sources --remove https://rubygems.org/ # 移除当前镜像源</span><br><span class="line">gem sources -a https://gems.ruby-china.com/ # 添加国内镜像源</span><br></pre></td></tr></table></figure></p><p>安装Cocoapods</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install cocoapods # Mac OS X 10.11前</span><br><span class="line">sudo gem install -n /usr/local/bin cocoapods # Mac OS X 10.11后</span><br></pre></td></tr></table></figure></p><p>更新Cocoapods/Specs</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.cocoapods/repos  </span><br><span class="line">pod repo remove master</span><br><span class="line">git clone https://gitee.com/mirrors/CocoaPods-Specs.git ~/.cocoapods/repos/ # 码云镜像源</span><br></pre></td></tr></table></figure></p><p>完全卸载Cocoapods</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem uninstall -n /usr/local/bin cocoapods cocoapods-core cocoapods-deintegrate cocoapods-downloader cocoapods-plugins cocoapods-search cocoapods-stats cocoapods-trunk cocoapods-try</span><br></pre></td></tr></table></figure></p><h4><span id="创建新项目">创建新项目</span></h4><p>如果你之前全局安装过旧的react-native-cli命令行工具，请使用npm uninstall -g react-native-cli卸载掉它以避免一些冲突。</p><p>现在初始化项目工具不需要安装<code>react-native-cli</code>，直接使用 <code>npx</code>命令（避免全局安装模块）</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx react-native init AwesomeProject</span><br></pre></td></tr></table></figure></p><p>注意事项：如果你身处国内并执行上面的命令，那么会卡在 <code>Installing CocoaPods dependencies</code> 这一步，原因是国内访问Cocoapods/Specs特别慢，造成超时。</p><p>Cocoapods新版本中即使你配置了国内镜像也没有效果，原因是你还差一步：进入自己的工程，在自己工程的podFile第一行加上：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source 'https://gitee.com/mirrors/CocoaPods-Specs.git'</span><br></pre></td></tr></table></figure></p><p>然后执行 <code>cd ./项目名/ios &amp;&amp; pod install</code> 就“万事大吉”了</p><h4><span id="编译并运行-react-native-应用">编译并运行 React Native 应用</span></h4><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd AwesomeProject</span><br><span class="line">yarn ios</span><br><span class="line"><span class="meta">#</span> 或者</span><br><span class="line">yarn react-native run-ios</span><br></pre></td></tr></table></figure></p><h4><span id="最后">最后</span></h4><p><strong>致敬那些提供国内镜像的开发者及组织！！！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;react-native之旅-1-环境搭建&quot;&gt;react native之旅-1 环境搭建&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;  无论哪种语言或技术，环境搭建是第一步，&lt;code&gt;react native&lt;/code&gt;也是如此。由于众所周知的原因，造成&lt;co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>那些年经历过的面试题</title>
    <link href="https://khadron.github.io/2020/05/06/%E9%82%A3%E4%BA%9B%E5%B9%B4%E7%BB%8F%E5%8E%86%E8%BF%87%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://khadron.github.io/2020/05/06/那些年经历过的面试题/</id>
    <published>2020-05-06T06:03:16.000Z</published>
    <updated>2020-07-20T03:09:05.298Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="那些年经历过的面试题">那些年经历过的面试题</span></h2><h3><span id="初级">初级</span></h3><h4><span id="javascript-基本数据类型有哪几种">Javascript 基本数据类型有哪几种？</span></h4><ul><li>boolean</li><li>null</li><li>undefined</li><li>number</li><li>string</li><li>symbol (es6 新增类型，表示独一无二的值，由 Symbol 函数生成)</li></ul><h4><span id="谈谈typeof">谈谈<code>typeof</code></span></h4><p><code>typeof</code> 对于基本数据类型来说，除了<code>null</code>都可以显示正确类型：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// "undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// "object" ???</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">0</span>; <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"hellow world"</span>; <span class="comment">// "string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// "boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure></p><p><code>typeof</code> 对于引用类型来说，除了函数都会显示为 Object</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// "object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>; <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure></p><h4><span id="如何准确地判断一个变量的数据类型">如何准确地判断一个变量的数据类型？</span></h4><ul><li>判断数组类型</li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 确定对象是否为指定的对象类型的实例，用来识别正在处理的对象的类型</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isPrototypeOf 判断一个对象是否存在另一个对象的原型链上</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf([]);</span><br></pre></td></tr></table></figure></p><ul><li>“万能”数据类型判断</li></ul><p><code>toString</code>会将this对象的<code>[[class]]</code>属性值拿到，而这个属性值就是该对象的真实类型</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.prototype.toString.call(变量) === "[数据类型]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">""</span>) === <span class="string">"[object String]"</span>;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) === <span class="string">"[object Array]"</span>;</span><br></pre></td></tr></table></figure></p><h4><span id="null-是对象吗">null 是对象吗？</span></h4><p>不是，在 JavaScript 最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头表示是对象，然而 null 表示为全零，所以将它错误判断为 Object</p><h4><span id="函数声明与函数表达式的区别">函数声明与函数表达式的区别？</span></h4><p>在JavaScript中，解析器会率先读取函数声明，并使其在执行任何代码之前可以访问，至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行</p><h4><span id="闭包是什么">闭包是什么？</span></h4><p>（未完待续）</p><h4><span id="浅拷贝和深拷贝">浅拷贝和深拷贝</span></h4><h4><span id="继承">继承</span></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;那些年经历过的面试题&quot;&gt;那些年经历过的面试题&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span id=&quot;初级&quot;&gt;初级&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span id=&quot;javascript-基本数据类型有哪几种&quot;&gt;Javascript 基本数据类型有哪几种
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复杂度分析</title>
    <link href="https://khadron.github.io/2020/05/04/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://khadron.github.io/2020/05/04/复杂度分析/</id>
    <published>2020-05-04T02:40:54.000Z</published>
    <updated>2020-08-12T00:00:02.266Z</updated>
    
    <content type="html"><![CDATA[<p>复杂度分析 是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p><h3><span id="为什么需要复杂度分析">为什么需要复杂度分析</span></h3><p>事后统计法：测试结果非常依赖测试环境测试结果受数据规模的影响很大</p><p>我们需要一个不用具体的测试数据来测试，就可以粗略地估算计算法的执行效率的方法。</p><h2><span id="时间-空间复杂度分析方法">时间、空间复杂度分析方法</span></h2><h3><span id="大-o-复杂度表示法">大 O 复杂度表示法</span></h3><p>算法的执行效率，粗略地讲，就是算法代码执行的时间。从 CPU 的角度来看，，每一行代码都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样。但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time(单位时间)。</p><p><strong>所有代码的执行时间 T(n)与每行代码的执行次数成正比。</strong><strong>执行多少次</strong></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">T(n) = O(f(n))</span><br></pre></td></tr></table></figure></p><p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度</p><h4><span id="时间复杂度分析">时间复杂度分析</span></h4><p>忽略低阶、常量、系数</p><ul><li><p>只关注循环执行次数最多的一段代码</p></li><li><p>加法法则：总复杂度等于量级最大的那段代码的复杂度</p></li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cal</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="number">100</span>; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">T(n) = O(max(fn(n),g(n)))</span><br></pre></td></tr></table></figure></p><ul><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cal</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        foo(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,i&lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。</span><br></pre></td></tr></table></figure></p><h3><span id="常见时间复杂度分析">常见时间复杂度分析</span></h3><ul><li><p>常量阶$O(1)$</p></li><li><p>对数阶$O(logn)$</p></li><li><p>线性阶$O(n)$</p></li><li><p>线性对数阶$O(n)$</p></li><li><p>平方阶$O(n^2)$ 、 立方阶$O(n^3)\cdots$ k 次方阶$O(n^k)$</p></li></ul><ul><li><p>指数阶$O(2^n)$</p></li><li><p>阶乘阶$O(n!)$</p></li></ul><p>对于复杂度量级，可以粗略分为两类，多项式量级和非多项式量级。其中非多项式量级只有两个$O(2^n)$和$O(n!)$</p><h3><span id="最好-最坏-平均-均摊情况时间复杂度">最好、最坏、平均、均摊情况时间复杂度</span></h3><h4><span id="最好情况时间复杂度best-case-time-complexity">最好情况时间复杂度（best case time complexity）</span></h4><p>在理想的情况下，执行这段代码的时间复杂度</p><h4><span id="最坏情况时间复杂度worst-case-time-complexity">最坏情况时间复杂度（worst case time complexity）</span></h4><p>在最糟糕的情况下，执行这段代码的时间复杂度</p><h4><span id="平均情况时间复杂度average-case-time-complexity">平均情况时间复杂度（average case time complexity）</span></h4><h4><span id="均摊时间复杂度amortized-time-complexity">均摊时间复杂度（amortized time complexity）</span></h4><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p><h3><span id="数学知识">数学知识</span></h3><h4><span id="对数">对数</span></h4><p>换底公式</p><h3><span id="数列">数列</span></h3><p>等差数列</p><h3><span id="概率">概率</span></h3><p>概率乘法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;复杂度分析 是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;为什么需要复杂度分析&quot;&gt;为什么需要复杂度分析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;事后统计法：
测试结果非常依赖测试环境
测试结果受数据规模的影响很大&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>指数与对数</title>
    <link href="https://khadron.github.io/2020/05/01/%E6%8C%87%E6%95%B0%E4%B8%8E%E5%AF%B9%E6%95%B0/"/>
    <id>https://khadron.github.io/2020/05/01/指数与对数/</id>
    <published>2020-05-01T06:33:30.000Z</published>
    <updated>2020-08-09T15:11:00.632Z</updated>
    
    <content type="html"><![CDATA[<p><img src="data:image/jpeg;base64,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" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAuKADAAQAAAAB
      
    
    </summary>
    
      <category term="数据结构" scheme="https://khadron.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数学" scheme="https://khadron.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>优雅的异步编程解决方案:async/await</title>
    <link href="https://khadron.github.io/2020/03/20/%E4%BC%98%E9%9B%85%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-async-await/"/>
    <id>https://khadron.github.io/2020/03/20/优雅的异步编程解决方案-async-await/</id>
    <published>2020-03-20T02:17:36.000Z</published>
    <updated>2020-04-04T12:29:58.684Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="优雅的异步编程解决方案asyncawait">优雅的异步编程解决方案:async/await</span></h2><p> 虽然 Promise 一定程度上解决了<code>回调地狱</code>的问题，但过多的链式调用也会造成代码可读性不好，而且流程控制也不方便。于是乎 ES7 提出了终极异步编程解决方案-<code>async/await</code>，可以使用同步的代码逻辑来编写异步的代码</p><h4><span id="先聊一聊-generator">先聊一聊 Generator</span></h4><p> 提到<code>async/await</code> 就不得不说<code>Generator（生成器）</code>，它出现在 async/await 之前的异步编程解决方案，<code>async/await</code> 实际上是对<code>Generator</code>的封装。所以在学习<code>async/await</code>之前了解<code>Generator</code>是有必要的 <code>Generator</code>函数是 ES6 提供的一种异步编程解决方案。从语法上理解，它是一个状态机，封装了多个内部状态。执行执行 Generator 函数会返回一个遍历器对象</p><ul><li>语法：</li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">hwGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"hello"</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">"world"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"ending"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = hwGenerator();</span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "world", done: false&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "ending", done: true&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p><p> 首先，<code>Generator</code> 形式上是一个普通的函数，它有两个特征。 function 关键字与函数名之间有一个<code>*</code>号；另一个是函数内部使用<code>yield</code>表达式，定义不同的状态。调用<code>next</code>方法是把<code>yield</code> 后面的内容返回</p><p> <code>yield</code> 表达式与 <code>return</code> 很相似，都是返回后面表达式的值。但也有区别，<code>return</code> 语句一个函数里面只能执行一次 ，但 <code>yield</code> 语句可以执行多次。<code>yield</code>还具有“记忆功能“（每次遇<code>yield</code>，函数就会暂停执行，下一次再从该位置继续向后执行），而 <code>return</code> 没有这个功能。在 <code>Generator</code> 函数中 <code>return</code> 表达式返回是 <code>done</code> 为 <code>true</code> 时的 <code>value</code></p><p> <code>yield</code>表达式本身没有返回值，<code>next</code>方法接收一个参数，该参数会被当做上一个 <code>yield</code>表达式返的返回值</p><p> <code>next</code>或<code>return</code>返回的是一个对象，里面有两个属性<code>value</code>和<code>done</code>，其中<code>done</code>为<code>true</code>表示 <code>Generator</code> 函数已经执行完成，后面再次调用 <code>next</code>也是这个值</p><p>Generator 函数原型方法</p><ul><li><p>Generator.prototype.throw 用于抛出错误，然后在 Generator 函数体内捕获，如果 Generator 函数体内没有捕获则抛出到 Generator 函数体外</p></li><li><p>Generator.prototype.return 返回给定的值并且终结 Generator 函数</p></li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> r1 = <span class="keyword">yield</span> num;</span><br><span class="line">    <span class="keyword">const</span> r2 = <span class="keyword">yield</span> r1 + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(r2);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"捕获错误"</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = fn(<span class="number">1</span>);</span><br><span class="line">g.next(<span class="number">2</span>); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">g.next(<span class="number">3</span>); <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line">g.throw(<span class="string">"出错了"</span>); <span class="comment">// 直接终止，done: true</span></span><br><span class="line">g.next();</span><br></pre></td></tr></table></figure></p><blockquote><p>这里需要注意一点，r1 的值不会保留上一次的值（也就是 2），而是直接用这次 <code>next</code> 方法传入的参数作为值，所以 <code>g.next(3)</code> 中 <code>yield r1+1</code>的 r1 为 3 而并非 2</p></blockquote><p> 那 <code>Generator</code> 函数内部是怎么实现的呢？我们借助<code>babel</code>可以窥探到其中的原理，使用 babel 转换上面的代码得到如下的结果：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"regenerator-runtime/runtime"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _marked = regeneratorRuntime.mark(hwGenerator);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hwGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> regeneratorRuntime.wrap(<span class="function"><span class="keyword">function</span> <span class="title">hwGenerator$</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          _context.next = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.abrupt(<span class="string">"return"</span>, <span class="string">"ending"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, _marked);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = hwGenerator();</span><br><span class="line">hw.next();</span><br><span class="line">hw.next();</span><br><span class="line">hw.next();</span><br><span class="line">hw.next();</span><br></pre></td></tr></table></figure></p><blockquote><p><a href="https://github.com/facebook/regenerator/tree/master/packages/regenerator-runtime#regenerator-runtime" target="_blank" rel="noopener">regenerator-runtime</a> 是 facebook 的开源项目<code>regenerator</code>里的模块，主要是提供<code>Generator</code>、<code>async/await</code>的 ES5 实现，所以 Babel 转换时就直接使用了<code>regenerator-runtime</code>来实现。</p></blockquote><p>  可以看到<code>yield</code>表达式都被转换为<code>switch-case</code>的形式了接下来，我们参考<code>regenerator-runtime</code>来实现一个简单的<code>Generator</code>，帮助我们更容易地理解背后的原理</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Generator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">" 'fn' is required"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">" 'fn' must be a function "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> context = &#123;</span><br><span class="line">    prev: <span class="number">0</span>,</span><br><span class="line">    next: <span class="number">0</span>,</span><br><span class="line">    done: <span class="literal">false</span>,</span><br><span class="line">    stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = fn(context);</span><br><span class="line">      <span class="keyword">if</span> (result === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        value: result,</span><br><span class="line">        done: <span class="literal">false</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          _context.next = <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">5</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">"ending"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorld();</span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "hello", done: false&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "world", done: false&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: "ending", done: true&#125;</span></span><br><span class="line">hw.next(); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p><h4><span id="generator-函数的流程管理">Generator 函数的流程管理</span></h4><p> 上面示例，我们都是手动调用 next 方法从而得到函数的结果，那能不能让 Generator 函数可以自动执行呢？这就涉及到 <code>Generator</code> 函数的流程管理 实现 Generator 函数的流程管理有两种方式<code>Thunk</code>和<code>Promise</code></p><ul><li><code>Thunk</code> 函数最初用于编译器参数求值策略-”传名调用“，Generator 函数出现后，它可用于 Generator 函数的自动执行。下面是一个简单的<code>Thunk</code>函数实现自动执行的示例</li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fileName);</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">      args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.apply(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        done(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFileThunkify = thunkify(readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFileThunkify(<span class="string">"路径1"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1);</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFileThunkify(<span class="string">"路径2"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gen = fn();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.value(next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Promise 实现</li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFilePromise = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(fileName);</span><br><span class="line">      resolve(<span class="string">"文件流"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFilePromise(<span class="string">"文件1"</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFilePromise(<span class="string">"文件2"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1;</span><br><span class="line">  <span class="built_in">console</span>.log(f2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure></p><blockquote><p>通过上面代码可以看出，自动执行的本质就是递归调用 <code>next</code>函数</p></blockquote><h3><span id="async-函数">async 函数</span></h3><p>聊完了<code>Generator</code>，接下步入正题来说下<code>async</code>函数</p><h4><span id="语法">语法</span></h4><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hw = <span class="keyword">await</span> <span class="string">"Hello World"</span>; <span class="comment">// 普通变量</span></span><br><span class="line">  <span class="built_in">console</span>.log(hw);</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// todo ……</span></span><br><span class="line">    resolved();</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.error(e));</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Promise"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = helloWorld();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></p><ul><li>async 函数很简单，跟普通函数相比，多了个 <code>async</code> 和 <code>await</code>关键字</li><li>async 函数执行的时，一旦遇到 await 就会先返回（把”执行权“交出去），等到异步操作完成，再接着执行函数后面的语句（收回”执行权“）</li><li>async 函数返回一个 Promise 对象，所以可以是使用 Promise 的 then 方法，比如：<code>helloWorld().then(v=&gt;console.log(v),e=&gt;console.log(e))</code></li><li>async 函数返回的 Promise 对象，只有函数内部的异步操作都完成后，才会发生状态改变，也就是执行 then 方法定义的回调函数参数</li><li>await 命令只能用于 async 函数之中，如果用在普通函数就会报错，</li><li>await 命令后面可以是一个 Promise 对象，也可以是普通的变量，如果是 Promise 则返回该对象的结果。反之则直接返回对应的值。如果 Promise 对象变为 reject 状态，那么整个 async 函数都会中断执行。有些时候我们想虽然发生错误但也不要中断，这是可以将出错的 await 语句放到<code>try...catch</code>里</li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">"出错了"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v));</span><br></pre></td></tr></table></figure></p><ul><li>需要注意如果将 <code>forEach</code> 方法参数改成 <code>async</code>函数的话，执行顺序不是依次执行的而是并发执行的</li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">data, i</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">  <span class="keyword">const</span> t = i === <span class="number">1</span> ? <span class="number">1000</span> : <span class="number">0</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> datas = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  datas.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">data, i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> handler(data, i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   如果想要得到依次执行的结果，可以使用 for 循环</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">data, i</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo</span></span><br><span class="line">  <span class="keyword">const</span> t = i === <span class="number">1</span> ? <span class="number">1000</span> : <span class="number">0</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> datas = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> data <span class="keyword">of</span> datas) &#123;</span><br><span class="line">    <span class="keyword">await</span> handler(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="aync-函数的优势">aync 函数的优势</span></h4><ul><li>更好的语义，<code>async</code>=异步，<code>await</code>=等候</li><li>更广的实用性， await 命令后面可以是 Promise 和原始类型值</li><li>返回 Promise，可以通过<code>then</code>方法指定下一步操作</li></ul><h4><span id="async-函数实现原理">async 函数实现原理</span></h4><p>前面说到 <code>async/await</code> 实际上是对 <code>Generator</code>的封装，准备的说它是由 <code>Generator</code>函数 + 自动执行器构成，结合前面讲的知识，我们就可以模拟实现 <code>async/await</code>函数了</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ctx = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">"function"</span>) gen = gen.call(ctx);</span><br><span class="line">    <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">"function"</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line"></span><br><span class="line">    onResolved();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onResolved</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.next(data);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = gen.throw(err);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      next(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">toPromise</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!obj &amp;&amp; <span class="string">'function'</span> == <span class="keyword">typeof</span> obj.then)&#123;</span><br><span class="line">            <span class="keyword">return</span> obj</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">      <span class="keyword">var</span> value= toPromise.call(ctx,ret.value);</span><br><span class="line">      <span class="keyword">if</span>(value)&#123;</span><br><span class="line">          <span class="keyword">return</span> value.then(onResolved, onRejected);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;优雅的异步编程解决方案asyncawait&quot;&gt;优雅的异步编程解决方案:async/await&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 虽然 Promise 一定程度上解决了&lt;code&gt;回调地狱&lt;/code&gt;的问题，但过多的链式调用也会造成代码可读性不好，而且流
      
    
    </summary>
    
      <category term="异步编程" scheme="https://khadron.github.io/categories/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>剖析Promise原理及实现</title>
    <link href="https://khadron.github.io/2018/03/14/%E5%89%96%E6%9E%90Promise%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://khadron.github.io/2018/03/14/剖析Promise原理及实现/</id>
    <published>2018-03-14T09:35:28.000Z</published>
    <updated>2020-08-10T14:10:35.130Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="剖析-promise-原理及实现">剖析 Promise 原理及实现</span></h2><h3><span id="promise-的是什么">Promise 的是什么</span></h3><p>Promise 字面的意思是“许诺、希望”，放到技术层面来说，它是一种异步编程解决方案。它与语言无关，你可以根据<a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promise/A+规范</a>,选用不同语言实现自己的 Promise。</p><h3><span id="promise-能解决什么问题">Promise 能解决什么问题？</span></h3><ul><li>解决回<code>调地狱</code>问题，比如下面：</li></ul><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAData</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo something</span></span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    callbak();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBData</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo something</span></span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCData</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// todo something</span></span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAData(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  getBData(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    getCData(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"callback hell"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><ul><li><p>代码更有条理，增加可读性</p></li><li><p>精确控制回调，防止回调次数过多、回调时机不对等问题</p></li></ul><h3><span id="promise-优点和缺点">Promise 优点和缺点</span></h3><h4><span id="优点">优点</span></h4><ul><li>代码有条理，更容易人阅读和理解</li><li>开发人员更安全的处理回调</li></ul><h4><span id="缺点">缺点</span></h4><ul><li>Promise 一旦创建，就会立即全部执行，无法取消</li><li>流程控制不太方便，不能跳过某些<code>then</code></li><li>如果不设置回调函数，Promsie 内部抛出错误，不会反应到外部</li><li>一堆 <code>then</code> 代码语义不清楚</li></ul><h3><span id="promise-状态">Promise 状态</span></h3><ul><li><p>Pending（进行中）</p></li><li><p>Resolved/Fulfilled（已完成）</p></li><li><p>Rejected （已失败）</p></li></ul><p>当 <code>Promise</code> 状态为 <code>pending</code> 时： <code>Promise</code> 状态可以转换为 <code>resolved</code> 或 <code>rejected</code>。</p><p>当 <code>Promise</code> 状态为 <code>resolved</code> 或 <code>rejected</code> 时：无法转换为其他状态。必须有一个不可改变的值作为 <code>onResolved</code> 或 <code>onRejected</code> 时间处理函数的参数</p><h3><span id="es6-标准的-promise-api">ES6 标准的 Promise API</span></h3><h4><span id="promiseprototypethenresolvehandlerrejecthandler">Promise.prototype.then(resolveHandler,[rejectHandler])</span></h4><p>Promise 状态发生改变后的处理，它接收两个参数，一个是 resolved 状态的处理函数，另一个是 reject 状态的处理函数（可选）。它的返回值是一个新的 Promise 对象</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>((resolved,rejected) = &gt;&#123;</span><br><span class="line">    resolved(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="comment">// rejected()</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function"><span class="params">ok</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;,failed=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'failed'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4><span id="promiseprototypecatchrejecthandler">Promise.prototype.catch(rejectHandler)</span></h4><p>Promise 状态为 rejected 的处理，它的返回值也是一个新的 Promise 对象</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">"err"</span>).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4><span id="promiseprototypefinallyfinallyhandler">Promise.prototype.finally(finallyHandler)</span></h4><p>无论 Promise 状态是 resolved 还是 rejected 都会执行。同样，它的返回值也是一个新的 Promise 对象</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">"err"</span>)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"finally"</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h4><span id="promisealliterable">Promise.all(iterable)</span></h4><p>执行多个 Promise，并且等待所有 Promise 状态变为 resolved，才会调用 then。如果其中一个 Promise 状态为 reject 就会调用 catch。 iterable 必须是一个可迭代的对象，同样，它的返回值也是一个新的 Promise 对象</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">"p1"</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.reject(<span class="string">"p2"</span>);</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p3]).then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line">  .then(<span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><h4><span id="promiseraceiterable">Promise.race(iterable)</span></h4><p>和<code>Promise.all</code>方法很像，只不过<code>Promise.race</code>方法只要有一个 Promise 状态变为 resolved 就会调用 then</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"p1"</span>);</span><br><span class="line">  &#125;, <span class="number">600</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"p1"</span>);</span><br><span class="line">  &#125;, <span class="number">800</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4><span id="promiseresolve">Promise.resolve</span></h4><p>返回一个状态为 <code>resovle</code> 的 <code>promise</code>对象</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">"ok"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1); <span class="comment">// Promise &#123;&lt;resolved&gt;: "ok"&#125;</span></span><br></pre></td></tr></table></figure></p><h4><span id="promisereject">Promise.reject</span></h4><p>返回一个状态为 <code>reject</code> 的 <code>promise</code>对象</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="string">"reject"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1); <span class="comment">// Promise &#123;&lt;reject&gt;: "failed"&#125;</span></span><br></pre></td></tr></table></figure></p><h3><span id="自己实现一个-promise">自己实现一个 Promise</span></h3><p>简单造轮子自己实现一个<code>Promise</code>，从而更好的理解<code>Promise</code>内部原理，从而知其所以然</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> executor !== <span class="string">"function"</span>) &#123;</span><br><span class="line">    <span class="comment">// executor必须是一个函数</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Promise executor"</span> + executor + <span class="string">"is not a function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="comment">// Promise(fn)方式也能正确执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(executor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.callbacks = [];</span><br><span class="line">  self.status = <span class="string">"pending"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.status !== <span class="string">"pending"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      self.status = <span class="string">"resolved"</span>;</span><br><span class="line">      self.data = value;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = self.callbacks.length; i &lt; len; i++) &#123;</span><br><span class="line">        self.callbacks[i].onResolved(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (self.status !== <span class="string">"pending"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      self.status = <span class="string">"rejected"</span>;</span><br><span class="line">      self.data = reason;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = self.callbacks.length; i &lt; len; i++) &#123;</span><br><span class="line">        self.callbacks[i].onRejected(reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handlePromise</span>(<span class="params">promise, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> then,</span><br><span class="line">    executed = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (promise === x) &#123;</span><br><span class="line">    <span class="comment">// 防止循环调用</span></span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Chaining cycle detected for promise!"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || <span class="keyword">typeof</span> x === <span class="string">"function"</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = x.then;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">"function"</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">rs</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (executed) &#123;</span><br><span class="line">              <span class="comment">// resolve方法只能执行一次</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            executed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> handlePromise(promise, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">rj</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (executed) &#123;</span><br><span class="line">              <span class="comment">// reject方法只能执行一次</span></span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            executed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      executed = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.then</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">"function"</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> v;</span><br><span class="line">        &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> r;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> newPromise;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">"resolved"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (newPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data); <span class="comment">// 回传处理后的值</span></span><br><span class="line">          <span class="comment">// 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数</span></span><br><span class="line">          handlePromise(promise, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">return</span> onRejected(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">"rejected"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (newPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data);</span><br><span class="line">          <span class="comment">// todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数</span></span><br><span class="line">          handlePromise(promise, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="keyword">return</span> onRejected(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">"pending"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (newPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.callbacks.push(&#123;</span><br><span class="line">        onResolved: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> x = onResolved(value);</span><br><span class="line">            <span class="comment">// todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数</span></span><br><span class="line">            handlePromise(promise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        onRejected: <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> x = onRejected(reason);</span><br><span class="line">            <span class="comment">// todo 判断x值是否为Promise对象，如果是则接收其结果作为下个then的传入参数</span></span><br><span class="line">            handlePromise(promise, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">      setTimeout(fn);</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">      setTimeout(fn);</span><br><span class="line">      <span class="keyword">throw</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    handlePromise(promise, value, resolve, reject);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>,</span><br><span class="line">      len = promises.length;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            counter++;</span><br><span class="line">            values[i] = value;</span><br><span class="line">            <span class="keyword">if</span> (counter === len) &#123;</span><br><span class="line">              <span class="keyword">return</span> resolve(values);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = promises.length; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> resolve(value);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;剖析-promise-原理及实现&quot;&gt;剖析 Promise 原理及实现&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span id=&quot;promise-的是什么&quot;&gt;Promise 的是什么&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Promise 字面的意思是“许诺、希望”，放
      
    
    </summary>
    
      <category term="异步编程" scheme="https://khadron.github.io/categories/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo 填坑指南</title>
    <link href="https://khadron.github.io/2018/02/02/Hexo-%E5%A1%AB%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>https://khadron.github.io/2018/02/02/Hexo-填坑指南/</id>
    <published>2018-02-02T06:30:07.000Z</published>
    <updated>2018-02-02T06:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="hexo-填坑指南">Hexo 填坑指南</span></h1><h2><span id="hexo安装成功并且正确运行但是localhost4000不能访问">hexo安装成功，并且正确运行，但是localhost:4000不能访问?</span></h2><ul><li><p>原因是：你的电脑端口被占用了。福昕阅读器占用了4000端口，而hexo默认的端口是4000，所以他俩端口冲突了</p></li><li><p>解决方案打开package.json文件增加如下代码：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">"scripts":&#123;</span><br><span class="line">    "start": "hexo s -p 4666"</span><br><span class="line">&#125;,</span><br><span class="line">//...</span><br></pre></td></tr></table></figure></p></li></ul><p>然后控制台执行<code>npm run start</code>命令</p><h2><span id="主题页面中分类和标签点进去有cannot-get-xxx提示">主题页面中【分类】和【标签】点进去有“Cannot GET /xxx/”提示</span></h2><p>解决方案：安装hexo-generator-json-content插件就好了，它会自动生成【分类】和【标签】的目录及文件</p><h2><span id="推荐hexo插件">推荐Hexo插件</span></h2><ul><li><a href="https://www.npmjs.com/package/hexo-generator-json-content" target="_blank" rel="noopener">hexo-generator-json-content</a></li><li><a href="https://www.npmjs.com/package/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a></li></ul><h2><span id="常用命令">常用命令</span></h2><table><thead><tr><th>命令</th><th>简写</th><th>含义</th></tr></thead><tbody><tr><td>hexo new &quot;name&quot;</td><td>hexo n &quot;name&quot;</td><td>新建文章</td></tr><tr><td>hexo generate</td><td>hexo g</td><td>生成博客</td></tr><tr><td>hexo server</td><td>hexo s</td><td>启动服务预览</td></tr><tr><td>hexo deploy</td><td>hexo d</td><td>部署</td></tr><tr><td>hexo clean</td><td></td><td>清除缓存</td></tr><tr><td>hexo new page 'name'</td><td></td><td>新建目录</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;hexo-填坑指南&quot;&gt;Hexo 填坑指南&lt;/span&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;span id=&quot;hexo安装成功并且正确运行但是localhost4000不能访问&quot;&gt;hexo安装成功，并且正确运行，但是localhost:4000不能访问?&lt;/span&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
